! function (e, t) {"use strict"; "object" == typeof module && "object" == typeof module.exports? module.exports? module.exports = e.document? t (e,! 0): function (e) {if (! e.document) lança novo erro ("jQuery requer uma janela com um documento"); retorna t (e)}: t (e)} ("indefinido"! = tipo de janela? window: this, function ( g, e) {"use strict"; var t = [], v = g.document, r = Object.getPrototypeOf, s = t.slice, y = t.concat, u = t.push, i = t. indexOf, n = {}, o = n.toString, m = n.hasOwnProperty, a = m.toString, l = a.call (Object), b = {}, x = function (e) {return "function" == tipo de e && "número"! = tipo de e.nodeType}, w = função (e) {return null! = e && e === e.window}, c = {type:! 0, src:! 0, nonce: ! 0, noModule:! 0}; função C (e, t, n) {var r, i, o = (n = n || v) .createElement ("script"); if (o.text = e, t) para (r em c) (i = t [r] || t.getAttribute && t.getAttribute (r)) && o.setAttribute (r, i); n.head.appendChild (o) .parentNode.removeChild (o)} função T (e) {return null == e? e + "": "object" = = typeof e || "function" == typeof e? n [o.call (e)] || "object": typeof e} var f = "3.4.1 -ajax, -ajax / jsonp, -ajax / load , -ajax / parseXML, -ajax / script, -ajax / var / location, -ajax / var / nonce, -ajax / var / rquery, -ajax / xhr, -manipulation / _evalUrl, -event / ajax, -effects, -effects / Tween, -effects / animatedSelector ", E = função (e, t) {retorna novo E.fn.init (e, t)}, d = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; função p (e) {var t = !! e && "comprimento" em e && e.length, n = T (e); retorno! x (e) &&! w (e) && ("matriz" === n || 0 === t || "número" == tipo de t && 0 <t && t-1 em e)} E.fn = E.prototype = {jquery: f, construtor: E, length: 0, toArray: function () {retorna s.call (this)}, obtém:função (e) {return null == e? s.call (this): e <0? this [e + this.length]: this [e]}, pushStack: function (e) {var t = E.merge (this.constructor (), e); return t.prevObject = this, t}, each: function (e) {retorna E.each (this, e)}, map: function (n) {retorna this.pushStack ( E.map (this, function (e, t) {return n.call (e, t, e)}))}, slice: function () {retorna this.pushStack (s.apply (this, argumentos))} , primeiro: function () {retorna this.eq (0)}, last: function () {retorna this.eq (-1)}, eq: function (e) {var t = this.length, n = + e + (e <0? t: 0); retorna this.pushStack (0 <= n && n <t? [este [n]]: [])}, fim: function () {retorna this.prevObject || this.constructor ( )}, pressione: u, classifique: t.sort, emenda: t.splice}, E.extend = E.fn.extend = function () {var e, t, n, r, i, o, a = argumentos [0] || {}, s = 1, u = argumentos.length, l =! 1; para ("booleano" == tipo de a && (l = a, a = argumentos [s] || {}, s ++) , "objeto" == tipo de a || x (a) || (a = {}), s === u &&(a = this, s -); s <u; s ++) if (null! = (e = argumentos [s])) para (t em e) r = e [t], "__ proto __"! == t && a ! == r && (l && r && (E.isPlainObject (r) || (i = Array.isArray (r)))? (n = a [t], o = i &&! Array.isArray (n)? []: i || E.isPlainObject (n)? N: {}, i =! 1, a [t] = E.extend (l, o, r)): vazio 0! == r && (a [t] = r) ); return a}, E.extend ({expando: "jQuery" + (f + Math.random ()). replace (/ \ D / g, ""), isReady:! 0, erro: function (e) {lança novo Erro (e)}, noop: function () {}, isPlainObject: function (e) {var t, n; return! (! e || "[objeto Objeto]"! == o.call (e )) && (! (t = r (e)) || "função" == tipoof (n = m.call (t, "construtor") && t.constructor) && a.call (n) === l)} , isEmptyObject: function (e) {var t; para (t em e) return! 1; return! 0}, globalEval: function (e, t) {C (e {nonce: t && t.nonce})}, cada : função (e, t) {var n, r = 0; se (p (e)) {para (n = e.length; r <n; r ++) if (! 1 === t.call (e [r], r, e [r])) break} else para (r em e) if (! 1 === t. call (e [r], r, e [r])) break; return e}, trim: function (e) {return null == e? "" :( e + ""). replace (d, "") } makeArray: function (e, t) {var n = t || []; return null! = e && (p (Object (e))? E.merge (n, "string" == tipo de e? [e ]: e): u.call (n, e)), n}, inArray: function (e, t, n) {return null == t? -1: i.call (t, e, n)}, mesclar: função (e, t) {para (var n = + comprimento t, r = 0, i = comprimento e; r <n; r ++) e [i ++] = t [r]; return e.length = i, e}, grep: function (e, t, n) {para (var r = [], i = 0, o = e.length, a =! n; i <o; i ++)! t (e [ i], i)! == a && r.push (e [i]); retorna r}, map: function (e, t, n) {var r, i, o = 0, a = []; if (p (e)) para (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) && a.push (i); mais para (o em e) null! = (i = t (e [o], o, n)) && a.push (i); retorna y.apply ([], a)}, guid: 1, suporte: b}), "função" == typeof Símbolo &&(E.fn [Symbol.iterator] = t [Symbol.iterator]), E.each ("Boolean Number String Função Matriz Data RegExp Object Error Symbol" .split (""), function (e, t) {n [ "[objeto" + t + "]"] = t.toLowerCase ()}); var h = função (n) {var e, p, x, o, i, h, f, g, w, u, l, C, T, a, E, v, s, c, y, N = "chiar" + 1 * nova data, m = n.documento, A = 0, r = 0, d = ue (), b = ue (), k = ue (), S = ue (), D = função (e, t) {retornar e === t && (l =! 0), 0}, L = {}. hasOwnProperty, t = [ ], j = t.pop, q = empurre, O = empurre, P = fatia, H = função (e, t) {para (var n = 0, r = comprimento; n < r; n ++) se (e [n] === t) retornar n; retornar-1}, I = "verificado | selecionado | assíncrono | autônomo | autofoco | autoplay | controles | adiar | desabilitado | oculto | ismap | loop | múltiplo | aberto | somente leitura | obrigatório | escopo ", R =" [\ x20 \\ t \\ r \\ n \\ f] ", B =" (?: \\\\. | [\\ w-] | [^ \ 0 - \\ xa0]) + ", M =" \\ ["+ R +" * ("+ B +") (?: "+ R +" * ([* ^ $ |! ~]? =) "+ R +"* (?: '((?: \\\\. | [^ \\\\']) *) '| \ "((?: \\\\. | [^ \\\\\"]) *) \ "| (" + B + ")) |)" + R + "* \\]", W = ":(" + B + ") (?: \\ ((('(?: \\\ \. | [^ \\\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ ") | ((?: \\ \\. | [^ \\\\ () [\\]] | "+ M +") *) |. *) \\) |) ", $ = new RegExp (R +" + "," g ") , F = new RegExp ("^" + R + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *)" + R + "+ $", "g" ), z = novo RegExp ("^" + R + "*," + R + "*"), _ = novo RegExp ("^" + R + "* ([> + ~] |" + R + ")" + R + "*"), U = novo RegExp (R + "|>"), V = novo RegExp (W), X = novo RegExp ("^" + B + "$"), Q = {ID: new RegExp ("^ # ("+ B +") "), CLASS: new RegExp (" ^ \\. ("+ B +") "), TAG: new RegExp (" ^ ("+ B +" | [*]) "), ATTR : new RegExp ("^ "+ M), PSEUDO: novo RegExp (" ^ "+ W), FILHO: novo RegExp (" ^ :( somente | primeiro | último | enésimo | enésimo-último) - (filho | do tipo) (?: \\ ("+ R +" * (par | ímpar | | ([+ -] |) (\\ d *) n |) "+ R +" * (?: ([+ -] |) "+ R +" * (\\ d +) |)) "+ R +" * \\) |) "," i "), bool: new RegExp (" ^ (?: "+ I +") $ "," i "), needsContext: new RegExp ("^" + R + "* [> + ~] |: (par | ímpar | eq | gt | lt | enésimo | primeiro | último) (?: \\ (" + R + "* ((?: - \\ d)? \\ d *) "+ R +" * \\) |) (? = [^ -] | $) "," i ")}, Y = / HTML $ / i, G = / ^ (?: input | select | textarea | button) $ / i, K = / ^ h \ d $ / i, J = / ^ [^ {] + \ {\ s * \ [nativo \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, ee = / [+ ~] /, te = new RegExp ("\\ \\ ([\\ da-f] {1,6} "+ R +"? | ("+ R +") |.) "," ig "), ne = função (e, t, n) {var r = "0x" + t-65536; retorna r! = R || n? T: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296,1023 & r | 56320)}, re = / ([\ 0- \ x1f \ x7f] | ^ -? \ d) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, ie = função (e, t) {retornar t? "\ 0" === e? "\ ufffd": e.slice (0, -1) + "\\" + e.charCodeAt (e.length-1) .toString (16) + "": "\\" + e}, oe = function () {C ()}, ae = xe (function (e) {return! 0 === e.disabled && "fieldset" === e.nodeName.toLowerCase ()}, {dir: "parentNode", próximo: "legend"}); tente {O.apply (t = P.call (m. childNodes), m.childNodes), t [m.childNodes.length] .nodeType} catch (e) {O = {apply: função t.length? (e, t) {q.apply (e, P.call ( t))}: function (e, t) {var n = e.length, r = 0; while (e [n ++] = t [r ++]); e.length = n-1}}} function se (t , e, n, r) {var i, o, a, s, u, l, c, f = e&& e.ownerDocument, d = e? e.nodeType: 9; if (n = n || [], " string "! = tipo de t ||! t || 1! == d && 9! == d && 11! == d) return n; if (! r && ((e? e.ownerDocument || e: m)! == T&& C (e), e = e || T, E)) {if (11! == d && (u = Z.exec (t))) if (i = u [ 1]) {if (9 === d) {if (! (A = e.getElementById (i))) retorna n; if (a.id === i) retorna n.push (a), n} caso contrário, se (f && (a = f.getElementById (i)) && y (e, a) && a.id === i) retorna n.push (a), n} else {if (u [2]) retorna O. apply (n, e.getElementsByTagName (t)), n; if ((i = u [3]) && p.getElementsByClassName && e.getElementsByClassName) retorna O.apply (n, e.getElementsByClassName (i)), n} if (p .qsa &&! S [t + ""] && (! v ||! v.test (t)) && (1! == d || "objeto"! == e.nodeName.toLowerCase ())) {if ( c = t, f = e, 1 === d && U.test (t)) {(s = e.getAttribute ("id"))? s = s.replace (re, ie): e.setAttribute ("id ", s = N), o = (l = h (t)). comprimento; enquanto (o -) l [o] =" # "+ s +" "+ seja (l [o]); c = l .join (","), f = ee.teste (t) && ye (e.parentNode) || e} tente {return O.apply (n, f.querySelectorAll (c)), n} catch (e) {S (t,! 0)} finalmente {s === N && e.removeAttribute ("id")}}} return g (t.replace (F, "$ 1"), e, n, r)} função ue () {var r = []; função de retorno e (t, n) {return r.push (t + "")> x.cacheLength && delete e [ r.shift ()], e [t + ""] = n}} função le (e) {retorno e [N] =! 0, e} função ce (e) {var t = T.createElement ("fieldset" ); tente {return !! e (t)} catch (e) {return! 1} finalmente {t.parentNode && t.parentNode.removeChild (t), t = null}} função fe (e, t) {var n = e.split ("|"), r = n.length; while (r -) x.attrHandle [n [r]] = t} função de (e, t) {var n = t && e, r = n && 1 = == e.nodeType && 1 === t.nodeType && e.sourceIndex-t.sourceIndex; if (r) retorna r; if (n) while (n = n.nextSibling) if (n === t) return-1; return e? 1: -1} função pe (t) {retornar função (e) {retornar "entrada" === e.nodeName.toLowerCase () && e.type === t}} function he (n) {return function (e) {var t = e.nodeName.toLowerCase (); return ("input" === t || "button" = == t) && e.type === n}} função ge (t) {retornar função (e) {retornar "formulário" em e? e.parentNode &&! 1 === e.disabled? "label" em e? "label" em e.parentNode? e.parentNode.disabled === t: e.disabled === t: e.isDisabled === t || e.isDisabled! ==! t && ae (e) === t : e.disabled === t: "label" em e && e.disabled === t}} função ve (a) {retornar le (função (o) {retornar o = + o, le (função (e, t) {var n, r = a ([], e.length, o), i = r.length; enquanto (i -) e [n = r [i]] && (e [n] =! (t [ n] = e [n]))})})} função ye (e) {retorne e && "indefinido"! = tipo de e.getElementsByTagName && e} para (e em p = se.support = {}, i = se.isXML = função (e) {var t = e.namespaceURI, n = (e.ownerDocument || e) .documentElement; return! Y.teste (t || n && n.nodeName || "HTML")}, C = se.setDocument = função (e) {var t, n, r = e? e.ownerDocument || e: m; return r! == T && 9 === r.nodeType && r.documentElement && (a = (T = r) .documentElement, E =! I (T), m! == T&& (n = T.defaultView) && n.top! == n && (n. addEventListener? n.addEventListener ("descarregar", oe,! 1): n.attachEvent && n.attachEvent ("onunload", oe)), p.attributes = ce (função (e) {retornar e.className = "i", ! e.getAttribute ("className")}), p.getElementsByTagName = ce (função (e) {retorne e.appendChild (T.createComment ("")) ,! e.getElementsByTagName ("*"). length}) , p.getElementsByClassName = J.test (T.getElementsByClassName), p.getById = ce (função (e) {retornar a.appendChild (e) .id = N,! T.getElementsByName ||! T.getElementsByName (N) .length}), p.getById? (x.filter.ID = função (e) {var t = e.substituir (te, ne); função de retorno (e) {retornar e.getAttribute ("id") === t}}, x.find.ID = função (e, t) {if ("undefined"! = typeof t.getElementById && E) {var n = t.getElementById (e); return n? [n]: []}}) :( x.filter.ID = função (e) {var n = e.replace (te, ne ); return function (e) {var t = "undefined"! = typeof e.getAttributeNode && e.getAttributeNode ("id"); return t && t.value === n}}, x.find.ID = function (e, t ) {if ("indefinido"! = tipo de t.getElementById && E) {var n, r, i, o = t.getElementById (e); if (o) {if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]; i = t.getElementsByName (e), r = 0; while (o = i [r ++]) if ((n = o.getAttributeNode ("id")) && n .valor === e) retornar [o]} retornar []}}), x.find.TAG = p.getElementsByTagName? function (e, t) {retornar "indefinido"! = tipo de t.getElementsByTagName? t.getElementsByTagName (e): p.qsa? t.querySelectorAll (e): void 0}: function (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ( "*" === e) {while (n = o [i ++]) 1 === n.nodeType && r.push (n); retorno r} retorno o}, x.find.CLASS = p.getElementsByClassName && function (e, t) {if ("indefinido"! = tipo de t.getElementsByClassName && E) retorna t.getElementsByClassName (e)}, s = [], v = [], (p.qsa = J.test (T.querySelectorAll)) && ( ce (function (e) {a.appendChild (e) .innerHTML = "<a id='"+N+"'> </a> <selecione id = '" + N + "- \ r \\' msallowcapture = ' '> <opção selecionada =' '> </option> </select> ", e.querySelectorAll (" [msallowcapture ^ =' '] "). length && v.push (" [* ^ $] = "+ R +" * (?: '' | \ "\") "), e.querySelectorAll (" [selecionado] ") .length || v.push ("\\ [" + R + "* (?: valor |" + I + ")"), e.querySelectorAll ("[id ~ =" + N + "-]"). length || v.push ("~ ="), e.querySelectorAll (": marcado"). length || v.push (": marcado"), e.querySelectorAll ("a #" + N + "+ *"). length || v.push (". #. + [+ ~]")}), ce (função (e) {e.innerHTML = "<a href='' disabled='disabled'> </a> < selecione disabled = 'disabled'> <opção /> </select> "; var t = T.createElement (" input "); t.setAttribute (" tipo "," oculto "), e.appendChild (t) .setAttribute ("name", "D"), e.querySelectorAll ("[name = d]"). length && v.push ("name" + R + "* [* ^ $ |! ~]? ="), 2! = = e.querySelectorAll (": enabled"). length && v.push (": enabled",": desativado"), a.appendChild (e) .disabled =! 0,2! == e.querySelectorAll (": disabled"). length && v.push (": enabled", ": disabled"), e.querySelectorAll ("*, x"), v.push (",. *:")})), (p.matchesSelector = J.test (c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce (função (e) {p.disconnectedMatch = c.call (e, "*"), c.call (e, "[s! = '']: x") , s.push ("! =", W)}), v = v.length && new RegExp (v.join ("|")), s = s.length && new RegExp (s.join ("|")), t = J.test (a.compareDocumentPosition), y = t || J.test (a.contains)? Function (e, t) {var n = 9 === e.nodeType? E.documentElement: e, r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r)))}: function (e, t) {if (t) while (t = t.parentNode) if (t === e) return! 0; return! 1}, D = t? function ( e, t) {if (e === t) retorna l =! 0,0; var n =! e.compareDocumentPosition-! t.compareDocumentPosition; retorna n || (1 & (n = (e.ownerDocument || e ) === (t.ownerDocument || t)? e.compareDocumentPosition (t): 1) ||! p.sortDetached && t.compareDocumentPosition (e) === n? e === T || e.ownerDocument == = m && y (m, e)? - 1: t === T || t.ownerDocument === m && y (m, t)? 1: u? H (u, e) -H (u, t): 0 : 4 & n? -1: 1)}: function (e, t) {if (e === t) retorna l =! 0,0; var n, r = 0, i = e.parentNode, o = t. parentNode, a = [e], s = [t]; if (! i ||! o) return e === T? -1: t === T? 1: i? -1: o? 1: u? H (u, e) -H (u, t): 0; se (i === o) retornar de (e, t); n = e; while (n = n.parentNode) a.unshift ( n); n = t; while (n = n.parentNode) s.unshift (n); while (a [r] === s [r]) r ++; return r? de (a [r], s [ r]): a [r] === m? -1: s [r] === m? 1: 0}), T}, se.matches = function (e, t) {return se (e, nulo, nulo, t)}, se.matchSelector = function (e, t) {if ((e.ownerDocument || e)! == T && C (e), p.matchesSelector && E &&! S [t + ""] && (! s ||! s.test (t) ) && (! v ||! v.test (t))) tente {var n = c.call (e, t); if (n || p.disconnectedMatch || e.document && 11! == e.document. nodeType) return n} catch (e) {S (t,! 0)} return 0 <se (t, T, nulo, [e]). length}, se.contains = function (e, t) {return ( e.ownerDocument || e)! == T&& C (e), y (e, t)}, se.attr = function (e, t) {(e.ownerDocument || e)! == T&& C (e); var n = x.attrHandle [t.toLowerCase ()], r = n && L.call (x.attrHandle, t.toLowerCase ())? n (e, t,! E): nulo 0; retorno nulo 0! == r? r: p.atributos ||! E? e.getAttribute (t) :( r = e.getAttributeNode (t)) && r.especificado? r.value: null}, se.escape = function (e) {return (e + ""). replace (re, ie)}, se.error = function (e) {lança novo erro ("Erro de sintaxe, expressão não reconhecida:" + e)}, se.uniqueSort = função (e) {var t, n = [], r = 0, i = 0; if (l =! p.detectDuplicates, u =! p.sortStable && e.slice (0), e.sort (D) , l) {while (t = e [i ++]) t === e [i] && (r = n.push (i)); while (r -) e.splice (n [r], 1) } retorna u = nulo, e}, o = se.getText = função (e) {var t, n = "", r = 0, i = e.nodeType; if (i) {if (1 === i || 9 === i || 11 === i) {if ("string" == tipo de e.textContent) retorna e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n + = o (e)} else if (3 === i || 4 === i) retorna e.nodeValue} else while (t = e [r ++]) n + = o (t); return n}, (x = se.selectors = {cacheLength: 50, createPseudo: le, match: Q, attrHandle: {}, encontre: {}, parente: {">": {dir: "parentNode", primeiro:! 0}, "" : {dir: "parentNode"}, "+": {dir: "previousSibling", primeiro:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (e) {return e [1] = e [1]. substitua (te, ne),e [3] = (e [3] || e [4] || e [5] || ""). substitua (te, ne), "~ =" === e [2] && (e [ 3] = "" + e [3] + ""), e.slice (0,4)}, CRIANÇA: função (e) {retornar e [1] = e [1] .toLowerCase (), "enésimo" === e [1]. fatia (0,3)? (e [3] || se.erro (e [0]), e [4] = + (e [4]? e [5] + ( e [6] || 1): 2 * ("par" === e [3] || "ímpar" === e [3])), e [5] = + (e [7] + e [8] || "ímpar" === e [3])): e [3] && se.error (e [0]), e}, PSEUDO: função (e) {var t, n =! E [ 6] && e [2]; return Q.CHILD.test (e [0])? Null: (e [3]? E [2] = e [4] || e [5] || "": n && V. teste (n) && (t = h (n,! 0)) && (t = n.indexOf (")", n.length-t) -n.length) && (e [0] = e [0] .slice (0, t), e [2] = n.slice (0, t)), e.slice (0,3))}}, filtro: {TAG: function (e) {var t = e. replace (te, ne) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}} ,CLASSE:função (e) {var t = d [e + ""]; retornar t || (t = novo RegExp ("(^ |" + R + ")" + e + "(" + R + "| $)")) && d (e, function (e) {return t.test ("string" == tipo de e.className && e.className || "indefinido"! = tipo de e.getAttribute && e.getAttribute ("classe") || "")})} , ATTR: função (n, r, i) {função de retorno (e) {var t = se.attr (e, n); retorno nulo == t? "! =" === r:! R || ( t + = "", "=" === r? t === i: "! =" === r? t! == i: "^ =" === r? i && 0 === t.indexOf (i): "* =" === r? i && - 1 <t.indexOf (i): "$ =" === r? i && t.slice (-i.length) === i: "~ = "=== r? -1 <(" "+ t.replace ($," ") +" ") .indexOf (i):" | = "=== r && (t === i || t. fatia (0, comprimento i + 1) === i + "-"))}}, CRIANÇA: function (h, e, t, g, v) {var y = "nésimo "! == h.slice (0,3), m =" last "! == h.slice (-4), b =" do tipo "=== e; retornar 1 === g && 0 == = função v (e) {return !! e.parentNode}: função (e, t, n) {var r, i, o, a, s, u, l = y! == m? "nextSibling": "previousSibling", c = e.parentNode, f = b && e.nodeName.toLowerCase (), d =! n &&! b, p =! 1; if (c) {if (y) {while (l) {a = e ; while (a = a [l]) if (b? a.nodeName.toLowerCase () === f: 1 === a.nodeType) return! 1; u = l = "somente" === h &&! u && "nextSibling"} retorna! 0} if (u = [m? c.firstChild: c.lastChild], m && d) {p = (s = (r = (i = (o = (a = c) [N] || (a [N] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] || []) [0] === A&& r [1]) && r [2], a = s && c.childNodes [s]; while (a = ++ s && a && a [l] || (p = s = 0) || u.pop ()) if (1 === a.nodeType && ++ p && a === e) {i [h] = [A, s, p]; break}} else if (d && (p = s = (r = (i = (o = (a = e) [N ] || (a [N] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] || []) [0] === A && r [1]) ,! 1 === p) enquanto (a = ++ s && a && a [l] || (p = s = 0) || u.pop ()) if ((b? a.nodeName.toLowerCase () === f: 1 === a.nodeType) && ++ p && ( d && ((i = (o = a [N] || (a [N] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] = [A, p]), a === e)) break; return (p- = v) === g || p% g == 0 && 0 <= p / g}}}, PSEUDO: function (e, o) { var t, a = x.pseudos [e] || x.setFilters [e.toLowerCase ()] || se.error ("pseudo não suportado:" + e); retorna um [N]? a (o): 1 <a.length? (t = [e, e, "", o], x.setFilters.hasOwnProperty (e.toLowerCase ())? le (função (e, t) {var n, r = a (e, o), i = r.length; while (i -) e [n = H (e, r [i])] =! (t [n] = r [i])}): function (e) { retornar a (e, 0, t)}): a}}, pseudos: {not: le (função (e) {var r = [], i = [], s = f (e.replace (F, " $ 1 ")); return s [N]? Le (function (e, t, n, r) {vari, o = s (e, null, r, []), a = e.length; while (a -) (i = o [a]) && (e [a] =! (t [a] = i))}):função (e, t, n) {retornar r [0] = e, s (r, nulo, n, i), r [0] = nulo,! i.pop ()}}), possui: le (function (t) {função de retorno (e) {retorno 0 <se (t, e). comprimento}}), contém: le (função (t) {retorno t = t.replace (te, ne), função (e) {return-1 <(e.textContent || o (e)). indexOf (t)}}), lang: le (função (n) {return X.test (n || "") || se.error ("lang não suportado:" + n), n = n. substituir (te, ne) .toLowerCase (), função (e) {var t; do {if (t = E? e.lang: e.getAttribute (" xml: lang ") || e.getAttribute (" lang ")) return (t = t.toLowerCase ()) === n || 0 === t.indexOf (n +" - ")} while ((e = e.parentNode) && 1 === e.nodeType); return! 1}}), target: function (e) {var t = n.location && n.location.hash; return t && t.slice (1) === .id}, raiz: função (e) {retornar e === a}, foco: função (e) {retornar e === T.activeElement && (! T.hasFocus || T.hasFocus ()) && !! (e.type || e.href || ~ e.tabIndex)},ativado: ge (! 1), desativado: ge (! 0), verificado: função (e) {var t = e.nodeName.toLowerCase (); retornar "input" === t && !! e.checked || " opção "=== t && !! e.selected}, selecionada: function (e) {return e.parentNode && e.parentNode.selectedIndex,! 0 === e.selected}, vazio: function (e) {for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType <6) return! 1; return! 0}, pai: função (e) {return! x.pseudos.empty (e)}, cabeçalho: função (e) {retornar K.test (e.nodeName)}, entrada: função (e) {retornar G.test (e.nodeName)}, botão: função (e) {var t = e.nodeName.toLowerCase ( ); return "input" === t && "button" === e.type || "button" === t}, texto: função (e) {var t; return "input" === e.nodeName .toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("type")) || "text" === t.toLowerCase ())}, primeiro:ve (função () {retorno [0]}), último: ve (função (e, t) {retorno [t-1]}), eq: ve (função (e, t, n) {retorno [n < 0? N + t: n]}), pares: ve (função (e, t) {para (var n = 0; n <t; n + = 2) e.push (n); retorno e}), ímpar : ve (função (e, t) {para (var n = 1; n <t; n + = 2) e.push (n); retorno e}), lt: ve (função (e, t, n) { for (var r = n <0? n + t: t <n? t: n; 0 <= - r;) e.push (r); retorno e}), gt: ve (função (e, t , n) {for (var r = n <0? n + t: n; ++ r <t;) e.push (r); retorno e})}}). pseudos.nth = x.pseudos.eq , {radio:! 0, caixa de seleção:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) x.pseudos [e] = pe (e); para (e em {submit:! 0, reset:! 0}) x.pseudos [e] = ele (e); função me () {} função ser (e) {para (var t = 0, n = comprimento.r, r = ""; t < n; t ++) r + = e [t] .valor; retornar r} função xe (s, e, t) {var u = e.dir, l = e.próximo, c = l || u, f = t && " parentNode "=== c, d = r ++; retorna e.first? função (e, t, n) {while (e = e [u]) if (1 === e.nodeType || f) retorna s ( e, t, n); return! 1}: function (e, t, n) {var r, i,o, a = [A, d]; if (n) {while (e = e [u]) if ((1 === e.nodeType || f) && s (e, t, n)) retornam! 0 } else while (e = e [u]) if (1 === e.nodeType || f) if (i = (o = e [N] || (e [N] = {})) [e. uniqueID] || (o [e.uniqueID] = {}), l && l === e.nodeName.toLowerCase ()) e = e [u] || e; else {if ((r = i [c]) && r [0] === A && r [1] === d) retorna a [2] = r [2]; if ((i [c] = a) [2] = s (e, t, n)) return! 0} return! 1}} função we (i) {return 1 <comprimento i? função (e, t, n) {var r = comprimento i; length (while - r) if (! i [r ] (e, t, n)) return! 1; return! 0}: i [0]} função Ce (e, t, n, r, i) {para (var o, a = [], s = 0 , u = e.length, l = nulo! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s));; return a} function Te (p, h, g, v, y, e) {return v &&! v [N] && (v = Te (v)), y &&! y [N ] && (y = Te (y, e)), le (função (e, t, n, r) {var i, o, a, s = [], u = [], l = comprimento t, c = função e || (e, t, n) {para (var r = 0, i = comprimento t; r <i; r ++) se (e, t [r], n); retorno n} (h | | "* ", n.nodeType? [n]: n, []), f =! p ||! e && h? c: Ce (c, s, p, n, r), d = g? y || (e ? p: l || v)? []: t: f; se (g && g (f, d, n, r), v) {i = Ce (d, u), v (i, [], n, r), o = i.length; while (o -) (a = i [o]) && (d [u [o]] =! (f [u [o]] = a))} if (e ) {if (y || p) {if (y) {i = [], o = d.length; while (o -) (a = d [o]) && i.push (f [o] = a ); y (nulo, d = [], i, r)} o = d.length; while (o -) (a = d [o]) && - 1 <(i = y? H (e, a ): s [o]) && (e [i] =! (t [i] = a))}} else d = Ce (d === t? d.splice (l, d.length): d) , y? y (nulo, t, d, r): O.aplicar (t, d)})} função Ee (e) {para (var i, t, n, r = e.length, o = x. relativo [e [0] .type], a = o || x.relativo [""], s = o? 1: 0, u = xe (função (e) {retorno e === i}, a, ! 0), l = xe (função (e) {return-1 <H (i, e)}, a,! 0), c = [função (e, t, n) {var r =! O && (n || t! == w) || ((i = t) .nodeType? u (e, t, n): l (e, t, n)); retorno i = nulo, r}]; s <r ; s ++) if (t = x.relativo [e [s] .type]) c = [xe (we (c), t)]; else {if ((t = x.filter [e [s] .type ] .apply (nulo, e [s].corresponde)) [N]) {para (n = ++ s; n <r; n ++) if (x.relative [e [n] .type]) break; return Te (1 <s && we (c), 1 < s && be (e.slice (0, s-1) .concat ({value: "" === e [s-2] .type? "*": ""})). replace (F, "$ 1") , t, s <n && Ee (e.slice (s, n)), n <r && Ee (e = e.slice (n)), n <r && be (e))} c.push (t)} return we (c )} retorna me.protótipo = x.filters = x.pseudos, x.setFilters = novo eu, h = se.tokenize = função (e, t) {var n, r, i, o, a, s, u, l = b [e + ""]; se (l) retornar t? 0: l.slice (0); a = e, s = [], u = x.preFilter; while (a) {for (o em n && ! (r = z.exec (a)) || (r && (a = a.slice (r [0] .length) || a), s.push (i = [])), n =! 1, (r = _. exec (a)) && (n = r.shift (), i.push ({valor: n, digite: r [0]. substitua (F, "")}), a = a. fatia (n.length)), x.filter)! (r = Q [o] .exec (a)) || u [o] &&! (r = u [o] (r)) || (n = r.shift (), i.push ({valor: n, tipo: o, corresponde a: r}), a = a.slice (n.length));if (! n) break} retorna t? a.length: a? se.error (e): b (e, s) .slice (0)}, f = se.compile = function (e, t) {var n, v, y, m, b, r, i = [], o = [], a = k [e + ""]; se (! a) {t || (t = h (e)), n = t.length; while (n -) (a = Ee (t [n])) [N]? i.push (a): o.push (a); (a = k (e, (v = o, m = 0 <(y = i) .length, b = 0 <v.length, r = função (e, t, n, r, i) {var o, a, s, u = 0, l = "0", c = e && [], f = [], d = w, p = e || b && x.find.TAG ("*", i), h = A + = nulo == d? 1: Matemática. random () || .1, g = p.length; para (i && (w = t === T || t || i); l! == g && null! = (o = p [l]); l ++ ) {if (b && o) {a = 0, t || o.ownerDocument === T || (C (o), n =! E); while (s = v [a ++]) if (s (o, t || T, n)) {r.push (o); break} i && (A = h)} m && ((o =! s && o) && u -, e && c.push (o))} if (u + = l , m && l! == u) {a = 0; while (s = y [a ++]) s (c, f, t, n); if (e) {if (0 <u) enquanto (l -) c [l] || f [l] || (f [l] = j.call (r)); f = Ce (f)} O.aplicar (r, f), i &&! e && 0 <f.length && 1 <u + y.length && se.uniqueSort (r)} retorna i && (A = h, w = d), c}, m? le (r): r))). seletor = e} retorna a}, g = se. select = function (e, t, n, r) {var i, o, a, s, u, l = "function" == tipo de e && e, c =! r && h (e = l.selector || e); se (n = n || [], 1 === comprimento c) {if (2 <(o = c [0] = c [0]. fatia (0)). length && "ID" === (a = o [0]). digite && 9 === t.nodeType && E && x.relative [o [1] .type]) {if (! (t = (x.find.ID (a.matches [0] .replace (te, ne), t) || []) [0])) return n; l && (t = t.parentNode), e = e.slice (o.shift (). value.length)} i = Q.needsContext. teste (e)? 0: o.length; while (i -) {if (a = o [i], x.relative [s = a.type]) quebra; if ((u = x.find [s ]) && (r = u (a.matches [0]. substitua (te, ne), ee.test (o [0] .type) && ye (t.parentNode) || t))) {if (o. splice (i, 1),! (e = r.length && be (o))) return O.apply (n, r), n; break}}} return (l || f (e, c)) (r, t,! E, n,! t || ee.test (e) && ye (t.parentNode) || t), n}, p.sortStable = N.split (""). sort (D) .join ("") === N, p.detectDuplicates = !! l, C (), p .sortDetached = ce (função (e) {return 1 & e.compareDocumentPosition (T.createElement ("fieldset"))}), ce (função (e) {return e.innerHTML = "<a href='#'> </ a> "," # "=== e.firstChild.getAttribute (" href ")}) || fe (" tipo | href | height | width ", função (e, t, n) {if (! n) return e.getAttribute (t, "type" === t.toLowerCase ()? 1: 2)}), p.attributes && ce (function (e) {return e.innerHTML = "<input />", e.firstChild .setAttribute ("value", ""), "" === e.firstChild.getAttribute ("value")}) || fe ("value", função (e, t, n) {if (! n && " input "=== e.nodeName.toLowerCase ()) retorna e.defaultValue}), ce (função (e) {return null == e.getAttribute ("disabled")}) || fe (I, função (e, t, n) {var r; if (! n) return! 0 === e [t]? t.toLowerCase () :( r = e.getAttributeNode (t)) && r.specified? r.value: null}), se} (g); E. encontrar = h, E.expr = h.seletores, E.expr [":"] = E .expr.pseudos, E.uniqueSort = E.unique = h.uniqueSort, E.text = h.getText, E.isXMLDoc = h.isXML, E.contains = h.contains, E.escapeSelector = h.escape; var N = função (e, t, n) {var r = [], i = nulo 0! == n; while ((e = e [t]) && 9! == e.nodeType) if (1 === e.nodeType) {if (i && E (e) .is (n)) break; r.push (e)} retorno r}, A = função (e, t) {for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e); return n}, k = E.expr.match.needsContext; função S (e, t) {return e.nodeName && e.nodeName .toLowerCase () === t.toLowerCase ()} var D = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; função L (e, n, r) {retorno x (n)? E.grep (e,função (e, t) {return !! n.call (e, t, e)! == r}): n.nodeType? E.grep (e, função (e) {return e === n! = = r}): "string"! = typeof n? E.grep (e, função (e) {return-1 <chamada.c (n, e)! == r}): E.filter (n, e , r)} E.filter = função (e, t, n) {var r = t [0]; retorno n && (e = ": not (" + e + ")"), 1 === comprimento t && 1 = == r.nodeType? E.find.matchesSelector (r, e)? [r]: []: E.find.matches (e, E.grep (t, função (e) {return 1 === e. nodeType}))}, E.fn.extend ({find: function (e) {var t, n, r = this.length, i = this; if ("string"! = typeof e) retorna this.pushStack ( E (e) .filter (função () {para (t = 0; t <r; t ++) if (E. contém (i [t], isto)) retorna! 0})); for (n = this. pushStack ([]), t = 0; t <r; t ++) E. encontrar (e, i [t], n); retornar 1 <r? E.uniqueSort (n): n}, filter: function (e ) {retorna this.pushStack (L (isto, e || [] ,! 1))}, não: function (e) {retorna this.pushStack (L (isso, e || [] ,! 0))} , é: function (e) {return !! L (this, "string "== tipo de e &&k.test (e)? E (e): e || [] ,! 1) .length}}); var j, q = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] +)) $ /; (E.fn.init = função (e, t, n) {var r, i; if (! E ) retorna isso; if (n = n || j, "string" == tipo de e) {if (! (r = "<" === e [0] && ">" === e [e.length -1] && 3 <= e.length? [Null, e, null]: q.exec (e)) ||! R [1] && t) return! T || t.jquery? (T || n). find (e): this.constructor (t) .find (e); if (r [1]) {if (t = t instância de E? t [0]: t, E.merge (this, E.parseHTML ( r [1], t && t.nodeType? t.ownerDocument || t: v,! 0)), D.test (r [1]) && E.isPlainObject (t)) para (r em t) x (este [r ])? this [r] (t [r]): this.attr (r, t [r]); retorna este} retorno (i = v.getElementById (r [2])) && (this [0] = i, this.length = 1), this} return e.nodeType? (this [0] = e, this.length = 1, this): x (e)? void 0! == n.ready? n.ready (e): e (E): E.makeArray (e, isto)}). prototype = E.fn, j = E (v); var O = / ^ (?:pais | prev (?: Até | Todos)) /, P = {filhos:! 0, conteúdo:! 0, próximo:! 0, prev:! 0}; função H (e, t) {while ((e = e [t]) && 1! == e.nodeType); return e} E.fn.extend ({has: function (e) {var t = E (e, this), n = t.length; retorne isso. filter (function () {for (var e = 0; e <n; e ++) if (E.contains (this, t [e])) return! 0})}, mais próximo: function (e, t) {var n, r = 0, i = this.length, o = [], a = "string"! = tipo de e && E (e); if (! k.test (e)) para (; r <i; r ++) para (n = this [r]; n && n! == t; n = n.parentNode) if (n.nodeType <11 && (a? -1 <a.index (n): 1 === n.nodeType && E.find. matchSelector (n, e))) {o.push (n); break} retorna this.pushStack (1 <o.length? E.uniqueSort (o): o)}, índice: function (e) {return e? "string" == tipo de e? i.call (E (e), este [0]): i.call (this, e.jquery? e [0]: e): this [0] && this [0]. parentNode? this.first (). prevAll (). length: -1}, add: function (e, t) {retorna this.pushStack (E.(); addBack: function (e) {retorna this.add (null == e? this.prevObject: this.prevObject.filter ( e))}}), E.each ({pai: função (e) {var t = e.parentNode; return t && 11! == t.nodeType? t: null}, pais: function (e) {return N ( e, "parentNode")}, parentsUntil: function (e, t, n) {return N (e, "parentNode", n)}, next: function (e) {return H (e, "nextSibling")}, prev: função (e) {retornar H (e, "irmão anterior")}, nextAll: função (e) {retornar N (e, "próximo irmão")}, prevAll: função (e) {retornar N (e, "previousSibling ")}, nextUntil: function (e, t, n) {retorna N (e," próximoSibling ", n)}, prevUntil: function (e, t, n) {retorna N (e," previousSibling ", n) } irmãos: função (e) {retorno A ((e.parentNode || {}). firstChild, e)}, filhos: função (e) {retorno A (e.firstChild)}, conteúdo: função (e) {Retorna"undefined "! = typeof e.contentDocument? e.contentDocument: (S (e," template ") && (e = e.content || e), E.merge ([], e.childNodes))}}, function (r, i) {E.fn [r] = função (e, t) {var n = E.map (isto, i, e); retorne "Até"! == r.slice (-5) && ( t = e), t && "string" == tipo de t && (n = E.filter (t, n)), 1 <this.length && (P [r] || E.uniqueSort (n), O.test (r ) && n.reverse ()), this.pushStack (n)}}); var I = / [^ \ x20 \ t \ r \ n \ f] + / g; função R (e) {retornar e} função B (e) {lança e} função M (e, t, n, r) {var i; tenta {e && x (i = e.promise)? i.call (e) .done (t) .fail (n): e && x (i = e.then)? i.call (e, t, n): t.apply (void 0, [e] .slice (r))} catch (e) {n.apply (void 0, [ e])}} E.Callbacks = function (r) {var e, n; r = "string" == tipo de r? (e = r, n = {}, E.each (e.match (I) | | [], função (e, t) {n [t] =! 0}), n): E. extender ({}, r); vari, t, o, a, s = [], u = [], l = -1, c = função () {para (a = a || r.uma vez, o = i =! 0; u.length; l = -1) {t = u.shift (); while (++ l <s.length)! 1 === s [l] .apply (t [0], t [1]) && r.stopOnFalse && (l = s.length, t =! 1)} r.memória || (t =! 1), i =! 1, a && (s = t? [] : "")}, f = {add: function () {return s && (t &&! i && (l = s.length-1, u.push (t)), função n (e) {E.each (e, function (e, t) {x (t)? r.unique && f.has (t) || s.push (t): t && t.length && "string"! == T (t) && n (t)})} ( argumentos), t &&! i && c ()), this}, remove: function () {retorna E.each (argumentos, função (e, t) {var n; while (-1 <(n = E.inArray (t, s, n))) s.splice (n, 1), n ​​<= l && l -}), this}, possui: function (e) {return e? -1 <E.inArray (e, s): 0 <s.length}, vazio: function () {retorna s && (s = []), isto}, desativa: function () {retorna a = u = [], s = t = "", isto}, desativado: function () {return! s}, lock: function () {retorna a = u = [], t || i || (s = t = ""), isto}, locked: function () {return !! a}, fireWith: function (e, t) {return a || (t = [e, (t = t || []). fatia? t .slice (): t], u.push (t), i || c ()), isto}, fire: function () {return f.fireWith (this, argumentos), this}, acionado: function () {return !! o}}; return f}, E.extend ({Adiado: função (e) {var o = [["notify", "progress", E.Callbacks ("memory")), E.Callbacks ( "memória"), 2], ["resolver", "pronto", E.Callbacks ("uma vez memória"), E.Callbacks ("uma vez memória"), 0, "resolvido"], ["rejeitar", " falha ", E.Callbacks (" uma vez memória "), E.Callbacks (" uma vez memória "), 1," rejeitado "]], i =" pendente ", a = {state: function () {return i}, always: function () {return s.done (argumentos) .fail (argumentos), isso}, "catch": function (e) {retorna a.then (null, e)}, pipe: function () {var i = argumentos; retornar E.Diferido (função (r) {E.cada (o, função (e, t) {var n = x (i [t [4]]) && i [t [4]]; s [t [1]] (função () {var e = n && n.apply (this, argumentos); e && x (e.promise)? e.promise (). progress (r.notify) .done (r.resolve) .fail (r.reject): r [t [0] + "With"] (isto, n? [e]: argumentos)})}), i = nulo}). promessa ()}, então: function (t, n, r) {var u = 0; função l (i, o, a, s) {função de retorno () {var n = isto, r = argumentos, e = função () {var e, t; se (! (I <u)) { if ((e = a.apply (n, r)) === o.promise ()) lança o novo TypeError ("Auto-resolução escalável"); t = e && ("objeto" == tipo de e || ") "== typeof e) &&.then, x (t)? s? t.call (e, l (u, o, R, s), l (u, o, B, s)) :( u ++, t .call (e, l (u, o, R, s), l (u, o, B, s), l (u, o, R, o.notifyWith))) :( a! == R && (n = void 0, r = [e]), (s || o.resolveWith) (n, r))}}, t = s? e: function () {tente {e ()} captura (e) {E .Deferred.exceptionHook && E.Deferred.exceptionHook (e, t.stackTrace), u <= i + 1 && (a! == B && (n = void 0, r = [e]), o.rejectWith (n, r))}}; i? t () :( E.Deferido .getStackHook && (t.stackTrace = E.Deferred.getStackHook ()), g.setTimeout (t))}} retornar E.Deferred (função (e) {o [0] [3] .adicionar (l (0, e , x (r)? r: R, e.notifyWith)), o [1] [3] .add (l (0, e, x (t)? t: R)), o [2] [3] .add (l (0, e, x (n)? n: B))}). promessa ()}, promessa: função (e) {retornar nulo! = e? E. extender (e, a): a }}, s = {}; retornar E.each (o, função (e, t) {var n = t [2], r = t [5]; a [t [1]] = n.adicionar, r && n .add (function () {i = r}, o [3-e] [2] .disable, o [3-e] [3] .disable, o [0] [2] .lock, o [0] [3] .lock), n.adicionar (t [3] .fire), s [t [0]] = função () {retornar s [t [0] + "Com"] (isto === s? void 0: isto, argumentos), isto}, s [t [0] + "With"] = n.fireWith}), a.promise (s), e && e.call (s, s), s}, quando: função (e) {var n = argumentos.length, t = n, r = matriz (t), i = s.call (argumentos), o = E.Deferido (), a = função (t) {função de retorno ( e) {r [t] = isso,i [t] = 1 <argument.length? s.call (argumentos): e, - n || o.resolveWith (r, i)}}; if (n <= 1 && (M (e, o.done (a (t)). resolve, o.rejeita,! n), "pendente" === o.state () || x (i [t] && i [t] .then))) return o.then ( ); while (t -) M (i [t], a (t), o.reject); return o.promise ()}}); var W = / ^ (Eval | Interno | Intervalo | Referência | Sintaxe | Tipo | URI) Erro $ /; E.Deferred.exceptionHook = função (e, t) {g.console && g.console.warn && e && W.test (nome.de) && g.console.warn ("jQuery.Deferred exception:" + e.message, e.stack, t)}, E.readyException = function (e) {g.setTimeout (function () {throw e})}; var $ = E.Deferred (); function F () {v .removeEventListener ("DOMContentLoaded", F), g.removeEventListener ("carga", F), E.ready ()} E.fn.ready = function (e) {return $ .then (e) ["catch"] (function (e) {E.readyException (e)}), este} E.extend ({isReady:! 1, readyWait: 1, ready:função (e) {(! 0 === e? - E.readyWait: E.isReady) || (E.isReady =! 0)! == e && 0 <- E.readyWait || $ .resolveWith (v , [E])}}), E.ready.then = $. Then, "complete" === v.readyState || "loading"! == v.readyState &&! V.documentElement.doScroll? G.setTimeout ( E.ready) :( v.addEventListener ("DOMContentLoaded", F), g.addEventListener ("carga", F)); var z = function (e, t, n, r, i, o, a) {var s = 0, u = comprimento e, l = nulo == n; se ("objeto" === T (n)) para (s em i =! 0, n) z (e, t, s, n [s] ,! 0, o, a); caso contrário, se (void 0! == r && (i =! 0, x (r) || (a =! 0), l && (a? (t.call (e , r), t = nulo) :( l = t, t = função (e, t, n) {retorna l.call (E (e), n)})), t)) para (; s <u ; s ++) t (e [s], n, a? r: r.call (e [s], s, t (e [s], n))); return i? e: l? t.call ( e): u? t (e [0], n): o}, _ = / ^ - ms - /, U = / - ([az]) / g; função V (e, t) {retorno t. toUpperCase ()} função X (e) {retornar e.replace (_, "ms -"). replace (U,V)} var Q = função (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + E.nodeType}; função Y () {this.expando = E.expando + Y.uid ++} Y.uid = 1, Y.prototype = {cache: function (e) {var t = e [this.expando]; return t || (t = {}, Q (e) && (e. nodeType? e [this.expando] = t: Object.defineProperty (e, this.expando, {valor: t, configurável:! 0}))), t}, conjunto: função (e, t, n) {var r, i = this.cache (e); if ("string" == tipo de t) i [X (t)] = n; caso contrário, para (r em t) i [X (r)] = t [r] ; return i}, get: function (e, t) {return void 0 === t? this.cache (e): e [this.expando] && e [this.expando] [X (t)]}, acesso : function (e, t, n) {return void 0 === t || t && "string" == tipo de t && void 0 === n? this.get (e, t) :( this.set (e, t , n), void 0! == n? n: t)}, remove: function (e, t) {var n, r = e [this.expando]; if (void 0! == r) {if ( void 0! == t) {n = (t = Array.isArray (t)? t.map (X) :( t = X (t)) em r? [t]: t.match (I) || []).comprimento;while (n -) delete r [t [n]]} (void 0 === t || E.isEmptyObject (r)) && (e.nodeType? e [this.expando] = void 0: delete e [ this.expando])}}, hasData: function (e) {var t = e [this.expando]; return void 0! == t && E.isEmptyObject (t)}}; var G = new Y, K = novo Y, J = / ^ (?: \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, Z = / [AZ] / g; função ee (e , t, n) {var r, i; if (void 0 === n && 1 === e.nodeType) if (r = "data -" + t.replace (Z, "- $ &"). toLowerCase ( ), "string" == typeof (n = e.getAttribute (r))) {try {n = "true" === (i = n) || "false"! == i && ("null" == = i? null: i === + i + ""? + i: J.test (i)? JSON.parse (i): i)} captura (e) {} K.set (e, t, n) } else n = void 0; return n} E.extend ({hasData: function (e) {return K.hasData (e) || G.hasData (e)}}, data: function (e, t, n) { return K.access (e, t, n)}, removeData: function (e, t) {K.remove (e, t)}, _ dados: função (e, t, n) {return G.access (e, t, n)},_removeData: function (e, t) {G.remove (e, t)}}), E.fn.extend ({data: function (n, e) {var t, r, i, o = this [0] , a = o && o.attributes; if (void 0 === n) {if (this.length && (i = K.get (o), 1 === o.nodeType &&! G.get (o, "hasDataAttrs") )) {t = a.length; while (t -) a [t] && 0 === (r = a [t] .name) .indexOf ("data -") && (r = X (r.slice (5)), ee (o, r, i [r])); G.set (o, "hasDataAttrs",! 0)} retorna i} retorna "objeto" == tipo de n? This.each (function ( ) {K.set (this, n)}): z (this, function (e) {var t; if (o && void 0 === e) retorna vazio 0! == (t = K.get (o, n ))? t: void 0! == (t = ee (o, n))? t: void 0; this.each (function () {K.set (this, n, e)})}, nulo, e, 1 <argument.length, null,! 0)}, removeData: function (e) {retorna this.each (function () {K.remove (this, e)})}}), E.extend ({ fila: função (e, t, n) {var r; se (e) retornar t = (t || "fx") + "fila", r = G.get (e, t), n && (!r || Matriz.isArray (n)? r = G.access (e, t, E.makeArray (n)): r.push (n)), r || []}, desenfileirar: função (e, t ) {t = t || "fx"; var n = E.queue (e, t), r = n.length, i = n.shift (), o = E._queueHooks (e, t); "inprogress "=== i && (i = n.shift (), r -), i && (" fx "=== t && n.unshift (" inprogress "), exclua o.stop, i.call (e, function () {E.dequeue (e, t)}, o)) ,! r && o && o.empty.fire ()}, _ queueHooks: function (e, t) {var n = t + "queueHooks"; return G.get (e, n ) || G.access (e, n, {vazio: E.Callbacks ("uma vez memória"). Add (function () {G.remove (e, [t + "fila", n])})})}) }), E.fn.extend ({fila: função (t, n) {var e = 2; retornar "string"! = Tipo de t && (n = t, t = "fx", e -), argumentos. length <e? E.queue (this [0], t): void 0 === n? this: this.each (function () {var e = E.queue (this, t, n); E._queueHooks (this, t), "fx" === t && "inprogress "! == e [0] && E.quequeue (this, t)})}, desenfileire: function (e) {retorne this.each (function () {E.dequeue (this, e)})}, clearQueue : function (e) {retorna this.queue (e || "fx", [])}, promessa: function (e, t) {var n, r = 1, i = E.Deferred (), o = this , a = this.length, s = function () {- r || i.resolveWith (o, [o])}; "string"! = tipo de e && (t = e, e = nulo 0), e = e || "fx"; while (a -) (n = G.get (o [a], e + "queueHooks")) && n.empty && (r ++, n.empty.add (s)); return s ( ), i.promise (t)}}); var te = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. origem, ne = new RegExp ("^ (?: ([+ -]) = |) (" + te + ") ([az%] *) $", "i"), re = ["Top", " Direita "," Inferior "," Esquerda "], ie = v.documentElement, oe = function (e) {retorna E.contains (e.ownerDocument, e)}, ae = {composta:! 0}; ie.getRootNode && (oe = function (e) {retorna E.contains (e.ownerDocument, e) || e.getRootNode (ae) === e.ownerDocument}); var se = function (e, t) {return "none" === (e = t || e) .style.display || "" === e.style.display && oe (e) && "none" === E.css (e, "display")}, ue = function (e, t, n, r) {var i, o, a = {}; para (o em t) a [o] = e.style [o], e.style [o] = t [o]; para (o em i = n.aplicar (e, r || []), t) e.style [o] = a [o]; retorno i}; var le = {}; função ce (e, t) {for (var n, r, i, o, a , s, u, l = [], c = 0, f = e.length; c <f; c ++) (r = e [c]). style && (n = r.style.display, t? ("none "=== n && (l [c] = G.get (r," exibição ") || nulo, l [c] || (r.style.display =" "))," "=== r. style.display && se (r) && (l [c] = (u = a = o = vazio 0, a = (i = r) .ownerDocument, s = i.nodeName, (u = le [s]) || ( o = a.body.appendChild (a.createElement (s)), u = E.css (o, "exibição"), o.parentNode.removeChild (o), "nenhum" === u && (u = "bloco "), le [s] = u)))):" nenhum "! == n && (l [c] =" nenhum ", G.set (r," exibição ", n))); for (c = 0; c <f; c ++) null! = L [c] && (e [c] .style.display = l [c]); return e} E.fn.extend ({show: function () {return ce (this,! 0)}, hide: function () {retorna ce (this)}, alterna: function (e) {retorna "booleano" == tipo de e? e? this.show (): this.hide ( ): this.each (function () {se (this)? E (this) .show (): E (this) .hide ()})}}); var fe = / ^ (?: caixa de seleção | radio) $ / i, de = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) / i, pe = / ^ $ | ^ módulo $ | \ / (?: java | ecma) script / i, he = {option: [1, "<select multiple = 'multiple'>", "</select>"], cabeçalho: [1, "<table>", "</ table > "], col: [2," <table> <colgroup> "," </colgroup> </table> "], tr: [2," <table> <tbody> "," </tbody> < / tabela>"], td: [3," <table> <tbody> <tr> "," </tr> </tbody> </table> "], _ padrão: [0," "," "]]; function ge (e, t) {var n; return n = "indefinido"! = tipo de e.getElementsByTagName? e.getElementsByTagName (t || "*"): "indefinido"! = tipo de e.querySelectorAll? e.querySelectorAll (t || "*"): [], nulo 0 === t || t && S (e, t)? E.merge ([e], n): n} função ve (e, t) {for (var n = 0, r = e.length; n <r; n ++) G.set (e [n], "globalEval",! T || G.get (t [n], "globalEval"))} he.optgroup = he.option, he.tbody = he.tfoot = he.colgroup = he.caption = he.thead, he.th = he.td; var ye, eu, seja = / <| & #? \ w +; / ; função xe (e, t, n, r, i) {para (var o, a, s, u, l, c, f = t.createDocumentFragment (), d = [], p = 0, h = e .length; p <h; p ++) if ((o = e [p]) || 0 === o) if ("objeto" === T (o)) E.merge (d, o.nodeType? [o]: o); caso contrário, se (seja.teste (o)) {a = a || f.appendChild (t.createElement ("div")), s = (de.exec (o) || ["", ""]) [1] .toLowerCase ( ), u = he [s] || he._default, a.innerHTML = u [1] + E.htmlPrefilter (o) + u [2], c = u [0]; enquanto (c -) a = a.lastChild; E.merge (d, a.childNodes), (a = f.firstChild) .textContent = ""} else d.push (t.createTextNode (o)); f.textContent = "", p = 0; while (o = d [p ++]) if (r && - 1 <E.inArray (o, r)) i && i.push (o); caso contrário, se (l = oe (o), a = ge (f.appendChild (o), "script"), l && ve (a), n) {c = 0; enquanto (o = a [c ++]) pe.test (o.type || "") && n.push (o)} return f} ye = v.createDocumentFragment (). appendChild (v.createElement ("div")), (me = v.createElement ("entrada")). setAttribute ("type", "radio"), me.setAttribute ( "marcado", "marcado"), me.setAttribute ("nome", "t"), ye.appendChild (eu), b.checkClone = ye.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, ye.innerHTML = "<textarea> x </textarea>", b.noCloneChecked = !! ye. cloneNode (! 0) .lastChild.defaultValue; var we = / ^ key /, Ce = / ^ (?: mouse | ponteiro | contextmenu | drag | drop) | clique em /, Te = / ^ ([^.] *) (?: \. (. +) |) /; função Ee () {retorno! 0} função Ne () {retorno! 1} função Ae (e, t) {retorno e === função () {tentativa { return v.activeElement} catch (e) {}} () == ("foco" === t)} função ke (e, t, n, r, i, o) {var a, s; if (" objeto "== tipo de t) {para (s em" string "! = tipo de n && (r = r || n, n = 0 nulo), t) ke (e, s, n, r, t [s], o); return e} if (null == r && null == i? (i = n, r = n = void 0): null == i && ("string" == tipo de n? (i = r, r = void 0) :( i = r, r = n, n = nulo 0)), 1 === i) i = i; caso contrário, se (! I) retornar e; retornar 1 === o && (a = i, (i = função (e) {retorna E (). off (e), a.apply (this, argumentos)}). guid = a.guid || (a.guid = E.guid ++)), e.each (function () {E.event.add (this, t, i, r, n)})} function Se (e, i, o) {o? (G. set (e, i,! 1), E.event.add (e, i, {espaço para nome:! 1, manipulador: function (e) {var t, n, r = G.get (this, i); if (1 & e.isTrigger && this [i]) {if (r.length) (E.event.special [i] || {}). DelegateType && e.stopPropagation (); caso contrário, se (r = s.call (argumentos), G. set (this, i, r), t = o (this, i), this [i] (), r! == (n = G.get (this, i)) || t? G.set (this , i,! 1): n = {}, r! == n) retorna e.stopImmediatePropagation (), e.preventDefault (), n.value} mais r.length && (G.set (this, i, {value : E.event.trigger (E.extend (r [0], E.Event.prototype), r.slice (1), este)}), e.stopImmediatePropagation ())}}): void 0 == = G.get (e, i) && E.event.add (e, i, Ee)} E.event = {global: {}, adicione: function (t, e, n, r, i) {var o, Se a resposta ajudou de alguma forma, por favor, marque como resposta, caso a sua dúvida não tenha sido solucionada, por favor, poste novamente. o.selector), i && E.find.matchesSelector (ou seja, i), n.guid || (n.guid = E.guid ++), (u = v.eventos) || (u = v.eventos = {}), (a = v.handle) || (a = v.handle = function (e) {return " undefined "! = tipo de E && E.event.triggered! == e.type? E.event.dispatch.apply (t, argumentos): nulo 0}), l = (e = (e ||" "). match ( I) || [""]). Length; while (l -) p = g = (s = Te.exec (e [l]) || []) [1], h = (s [2] || ""). split ("."). sort (), p && (f = E.event.special [p] || {}, p = (i? f.delegateType: f.bindType) || p , f = E.event.special [p] || {}, c = E.extend ({type: p, origType: g, dados: r, manipulador: n, guid: n.guid, seletor: i, needsContext : i && E.expr.match.needsContext.test (i), namespace: h.join (".")}, o), (d = u [p]) || ((d = u [p] = [] ) .delegateCount = 0, f.setup &&! 1! == f.setup.call (t, r, h, a) || t.addEventListener && t.addEventListener (p, a)), f.add && (f.add. chamada (t, c), c.handler.guid || (c.handler.guid = n.guid)), i? d.splice (d.delegateCount ++, 0, c): d.push (c), E.event.global [p] =! 0)}}, remove: function (e, t, n, r, i) {var o, a, s, u, l, c, f, d, p, h, g, v = G.hasData (e) && G.get (e); if (v && (u = v.eventos)) {l = (t = (t || ""). match ( I) || [""]). Length; while (l -) if (p = g = (s = Te.exec (t [l]) || []) [1], h = (s [ 2] || ""). Split ("."). Sort (), p) {f = E.event.special [p] || {}, d = u [p = (r? F.delegateType: f.bindType) || p] || [], s = s [2] && new RegExp ("(^ | \\.)" + h.join ("\\. (?:. * \\. |) ") +" (\\. | $) "), a = o = d.length; while (o -) c = d [o] ,! i && g! == c.origType || n && n.guid! = = c.guid || s &&! s.test (c.namespace) || r && r! == c.selector && ("**"! == r ||! c.selector) || (d.splice (o, 1), c.selector && d.delegateCount -, f.remove && f.remove.call (e, c)); a &&! D.length && (f.teardown &&! 1! == f.teardown.call (e, h, v .handle) || E.removeEvent (e, p, v.manipule), exclua u [p])} else para (p in u) E.event.remove (e, p + t [l], n, r,! 0); E.isEmptyObject (u) && G.remove ( e, "manipular eventos")}}, despacho: function (e) {var t, n, r, i, o, a, s = E.event.fix (e), u = new Array (argumentos.length) , l = (G.get (this, "events") || {}) [s.type] || [], c = E.event.special [s.type] || {}; for (u [ 0] = s, t = 1; t <argumentos.length; t ++) u [t] = argumentos [t]; if (s.delegateTarget = this,! C.preDispatch ||! 1! == c.preDispatch. call (this, s)) {a = E.event.handlers.call (this, s, l), t = 0; while ((i = a [t ++]) &&! s.isPropagationStopped ()) {s. currentTarget = i.elem, n = 0; while ((o = i.handlers [n ++]) &&! s.isImmediatePropagationStopped ()) s.rnamespace &&! 1! == o.namespace &&! s.rnamespace.test (o. namespace) || (s.handleObj = o, s.data = o.data, void 0! == (r = ((E.event.special [o.origType] || {}). handle || o. manipulador) .apply (i.elem, u)) &&! 1 === (s.result = r) && (s.preventDefault (), s.stopPropagation ()))} retorna c.postDispatch && c.postDispatch.call (este, s), s.result}}, manipuladores: function (e, t) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType &&! ("click" === e.type && 1 <= e.button)) para (; l! == this ; l = l.parentNode || this) if (1 === l.nodeType && ("click"! == e.type ||! 0! == l.disabled)) {for (o = [], a = {}, n = 0; n <u; n ++) nulo 0 === a [i = (r = t [n]). seletor + ""] && (a [i] = r.needsContext? -1 < E (i, this) .index (l): E.find (i, this, null, [l]). Length), a [i] && o.push (r); o.length && s.push ({elem: l, manipuladores: o})} return l = this, u <t.length && s.push ({elem: l, manipuladores: t.slice (u)}), s}, addProp: function (t, e) {Object .defineProperty (E.Event.prototype, t, {enumerable:! 0, configurable:! 0, get: x (e)? function () {if (this.originalEvent) return e (this.originalEvent)}:function () {if (this.originalEvent) retorna this.originalEvent [t]}, set: function (e) {Object.defineProperty (this, t, {enumerable:! 0, configurable:! 0, configurável:! 0, gravável:! 0, valor: e})}})}, corrija: function (e) {return e [E.expando]? e: new E.Event (e)}, especial: {load: {noBubble:! 0}, clique em: {setup: function (e) {var t = this || e; return fe.test (t.type) && t.click && S (t, "input") && Se (t, "clique", Ee) ,! 1}, trigger: function (e) {var t = this || e; return fe.test (t.type) && t.click && S (t, "input") && Se (t, "click") ,! 0}, _ default: function (e) {var t = e.target; retorna fe.test (t.type) && t.click && S (t, "entrada") && G.get (t, "clique") || S (t, "a") }}, antes da descarga: {postDispatch: function (e) {void 0! == e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)}}}}, E.removeEvent = function (e, t, n) {e.removeEventListener && e.removeEventListener (t, n)}, E.Event = function (e, t) {if (! (this instance of E.Event)) retorna novo E.Event (e, t); e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented &&! 1 === e.returnValue ? Ee: Ne, this.target = e.target && 3 === e.target.nodeType? E.target.parentNode: e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget): this. type = e, t && E.extend (this, t), this.timeStamp = e && e.timeStamp || Date.now (), this [E.expando] =! 0}, E.Event.prototype = {construtor: E. Evento, isDefaultPrevented: Ne, isPropagationStopped: Ne, isImmediatePropagationStopped: Ne, isSimulated:! 1, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = Ee, e && this.isSimulated &&.prevent, &stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = Ee, e &&! this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: função () {var e = this.originalEvent; this.isImmediate = ! this.isSimulated && e.stopImmediatePropagation (), this.stopPropagation ()}}, E.each ({altKey:! 0, bolhas:! 0, cancelável:! 0, modifiedTouches:! 0, ctrlKey:! 0, detalhe :! 0, eventPhase:! 0, metaKey:! 0, páginaX:! 0, páginaY:! 0, shiftKey:! 0, visualização:! 0, "char":! 0, código:! 0, charCode:! 0, key :! 0, keyCode:! 0, botão:! 0, botões:! 0, clientX:! 0, clientY:! 0, offsetX:! 0, offsetY:! 0, pointerId:! 0, pointerType:! 0, screenX :! 0, screenY:! 0, targetTouches:! 0, toElement:! 0, toca:! 0, que: function (e) {var t = e.button; return null == e.que & & nós.teste (e. Digite)? null! = e.charCode? e.charCode: e.keyCode:! e.which && void 0! == t && Ce.test (e.type)? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e.qual}}, E.event.addProp), E.each ({focus: "focusin", blur: "focusout"}}, function ( e, t) {E.event.special [e] = {setup: function () {return Se (this, e, Ae) ,! 1}, trigger: function () {return Se (this, e) ,! 0}, delegateType: t}}), E.each ({mouseenter: "mouseover", mouseleave: "mouseout", ponteiro: "ponteiro", ponteiro: "ponteiro", função (e, i) {E.event .special [e] = {delegateType: i, bindType: i, handle: function (e) {var t, n = e.relatedTarget, r = e.handleObj; return n && (n === this || E.contains (this, n)) || (e.type = r.origType, t = r.handler.apply (isso, argumentos), e.type = i), t}}}), E.fn.extend ({ on: function (e, t, n, r) {return ke (this, e, t, n, r)}, one: function (e, t, n, r) {return ke (this, e, t, n, r, 1)}, off: function (e, t, n) {var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, E (e.delegateTarget) .off (r.namespace? r.origType + "." + r.namespace: r.origType, r.selector, r.handler), this; if ("object" == typeof e) {for (i in e) this.off (i, t, e [i]); retorna este} return! 1! == t && "function"! = typeof t || (n = t, t = void 0) ,! 1 == = n && (n = Ne), this.each (function () {E.event.remove (this, e, n, t)})}}); var De = / <(?! area | br | col | embed | hr | img | input | link | meta | param) (([az] [^ \ / \ 0 > \ x20 \ t \ r \ n \ f] *) [^>] *) \ /> / gi, Le = / <script | <estilo | <estilo | <link / i, je = / marcado \ s * (?: [^ =] | = \ s *. verificado.) / i, qe = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g; função Oe (e, t) {retorna S (e, "tabela") && S (11! == t.nodeType? t: t.firstChild, "tr") && E (e) .children ("tbody") [0] || e} função Pe (e) {retornar e.type = (nulo! == e.getAttribute ("tipo")) + "/" + e.type, e} função He (e) {return "true /" === (e.type || ""). slice (0,5)? e.type = e.type.slice (5): e.removeAttribute ("type") , e} função Ie (e, t) {var n, r, i, o, a, s, u, l; if (1 === t.nodeType) {if (G.hasData (e) && (o = G.access (e), a = G.set (t, o), l = o.events)) para (i em excluir a.handle, a.events = {}, l) para (n = 0, r = l [i] .length; n <r; n ++) E.event.add (t, i, l [i] [n]); K.hasData (e) && (s = K.access (e), u = E. extensão ({}, s), K.set (t, u))}} função Re (n, r, i, o) { r = y.aplicar ([], r); var e, t, a, s, u, l, c = 0, f = comprimento n, d = f-1, p = r [0], h = x (p); if (h || 1 <f && "string" == tipo de p &&! b.checkClone && je.test (p)) return n.each (function (e) {var t = n.eq (e); h && (r [0] = p.call (this, e, t.html ())), Re (t, r, i, o)}); if (f && (t = (e = xe (r, n [0] .ownerDocument,! 1, n, o)). FirstChild, 1 === e.childNodes.length && (e = t), t || o)) {for (s = (a = E.map ( ge (e, "script"), Pe)). length; c <f; c ++) u = e, c! == d && (u = E.clone (u,! 0,! 0), s && E.merge ( a, ge (u, "script"))), i.call (n [c], u, c); if (s) para (l = a [a.length-1] .ownerDocument, E.map ( a, He), c = 0; c <s; c ++) u = a [c], pe.test (u.type || "") &&! G.access (u, "globalEval") && E.contains ( l, u) && (u.src && "module"! == (u.type || "") .toLowerCase ()? E._evalUrl &&! u.noModule && E._evalUrl (u.src, {nonce: u.nonce || u.getAttribute ("nonce")}): C (u.textContent.replace (qe, " "), u, l))} retornar n} função Be (e, t, n) {para (var r, i = t? E.filtro (t, e): e, o = 0; nulo! = ( r = i [o]); o ++) n || 1! == r.nodeType || E.cleanData (ge (r)), r.parentNode && (n && oe (r) && ve (ge (r, "script")) ), r.parentNode.removeChild (r)); return e} E.extend ({htmlPrefilter: function (e) {return e.replace (De, "<$ 1> </ $ 2>")}, clone: ​​function ( e, t, n) {var r, i, o, a, s, u, l, c = e.cloneNode (! 0), f = oe (e); if (! (b.noCloneChecked || 1! == e.nodeType && 11! == e.nodeType || E.isXMLDoc (e))) para (a = ge (c), r = 0, i = (o = ge (e)). length; r <i ; r ++) s = o [r], u = a [r], nulo 0, "entrada" === (l = u.nodeName.toLowerCase ()) && fe.test (s.type)? u.checked = s.checked: "input"! == l && "textarea"!== l || (u.defaultValue = s.defaultValue); if (t) if (n) para (o = o || ge (e), a = a || ge (c), r = 0, i = o.length; r <i; r ++) Ie (o [r], a [r]); caso contrário, Ie (e, c); return 0 <(a = ge (c, "script")). length && ve ( a,! f && ge (e, "script")), c}, cleanData: function (e) {for (var t, n, r, i = E.event.special, o = 0; void 0! == ( n = e [o]); o ++) if (Q (n)) {if (t = n [G.expando]) {if (t.events) for (r in t.events) i [r]? E .event.remove (n, r): E.removeEvent (n, r, t.handle); n [G.expando] = nulo 0} n [K.expando] && (n [K.expando] = nulo 0 )}}}), E.fn.extend ({desanexar: função (e) {retornar Be (isto, e,! 0)}, remover: função (e) {retornar ser (este, e)}, texto: function (e) {return z (this, function (e) {return void 0 === e? E.text (this): this.empty (). each (function () {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || (this.textContent = e)})}, nulo, e, argumentos. comprimento)}, acrescente: function () {return Re (this, argumentos,function (e) {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || Oe (isso, e) .appendChild (e)})}, prefixo: function () {return Re ( isso, argumentos, função (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = Oe (this, e); t. insertBefore (e, t.firstChild)}})}, before: function () {return Re (this, argumentos, função (e) {this.parentNode && this.parentNode.insertBefore (e, this)})}, depois: function () {return Re (argumentos, função (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, vazio: function () {for (var e, t = 0; null! = (e = this [t]); t ++) 1 === e.nodeType && (E.cleanData (ge (e,! 1)), e.textContent = ""); retorne isso}, clone: ​​function (e , t) {return e = null! = e && e, t = null == t? e: t, this.map (function () {return E.clone (this, e, t)})}, html: function ( e) {retornar z (isto, função (e) {var t = isto [0] || {}, n = 0, r = isto.length; if (void 0 === e && 1 === t.nodeType) retorna t.innerHTML; if ("string" == tipo de e &&! Le.test (e) &&! he [(de.exec (e) | | ["", ""]) [1] .toLowerCase ()]) {e = E.htmlPrefilter (e); tente {for (; n <r; n ++) 1 === (t = this [n] || {}). nodeType && (E.cleanData (ge (t,! 1)), t.innerHTML = e); t = 0} captura (e) {}} t && this.empty (). append (e)} , null, e, argument.length)}, replaceWith: function () {var n = []; return Re (this, argumentos, função (e) {var t = this.parentNode; E.inArray (this, n) <0 && (E.cleanData (ge (this)), t &&.replaceChild (e, this))}, n)}}), E.each ({appendTo: "append", prependTo: "prepend", insertBefore: " before ", insertAfter:" after ", replaceAll:" replaceWith "}, função (e, a) {E.fn [e] = função (e) {for (var t, n = [], r = E (e ), i = r.length-1, o = 0; o <= i; o ++) t = o === i? this: this.clone (! 0),E (r [o]) [a] (t), u.apply (n, t.get ()); retorna this.pushStack (n)}}); var Me = new RegExp ("^ (" + te + ") (?! px) [az%] + $", "i"), We = function (e) {var t = e.ownerDocument.defaultView; return t &&op.opener || (t = g), t. getComputedStyle (e)}, $ e = new RegExp (re.join ("|"), "i"); função Fe (e, t, n) {var r, i, o, a, s = e.style ; return (n = n || We (e)) && (""! == (a = n.getPropertyValue (t) || n [t]) || oe (e) || (a = E.style (e, t)) ,! b.pixelBoxStyles () && Me.test (a) && $ e.test (t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), nulo 0! == a? a + "": a} function ze (e, t) {return {get: function () {if (! e ()) return (this.get = t) .apply (this, argument); exclua this.get}}}! function () {function e () {if (u) {s.style.cssText = "position: absolute; left: -11111px; width: 60px;margin-top: 1px; padding: 0; border: 0 ", u.style.cssText =" posição: relativa; exibição: bloco; tamanho da caixa: borda-caixa; estouro: rolagem; margem: automático; borda: 1px; preenchimento: 1px; largura: 60%; superior: 1% ", ie.appendChild (s) .appendChild (u); var e = g.getComputedStyle (u); n =" 1% "! == e.top, a = 12 === t (e.marginLeft), u.style.right = "60%", o = 36 === t (e.right), r = 36 === t (e.width), u.style.posição = "absoluto", i = 12 === t (u.offsetWidth / 3), ie.removeChild (s), u = null}} função t (e) {retorna Math.round (parseFloat ( e))} var n, r, i, o, a, s = v.createElement ("div"), u = v.createElement ("div"); u.style && (u.style.backgroundClip = "content- caixa ", u.cloneNode (! 0) .style.backgroundClip =" ", b.clearCloneStyle =" caixa de conteúdo "=== u.style.backgroundClip, E.extend (b, {boxSizingReliable: function () {return e (), r}, pixelBoxStyles: function () {return e (),o}, pixelPosition: function () {retornar e (), n}, confiávelMarginLeft: function () {retornar e (), a}, scrollboxSize: function () {retornar e (), i}}))} () ; var _e = ["Webkit", "Moz", "ms"], Ue = v.createElement ("div"). style, Ve = {}; função Xe (e) {var t = E.cssProps [e ] || Ve [e]; return t || (e em Ue? E: Ve [e] = função (e) {var t = e [0] .toUpperCase () + e.slice (1), n ​​= _e.length; while (n -) if ((e = _e [n] + t) em Ue) retorna e} (e) || e)} var Qe, Ye, Ge = / ^ (nenhum | tabela ( ?! - c [ea]). +) /, Ke = / ^ - /, Je = {position: "absolute", visibilidade: "hidden", exibição: "block"}, Ze = {letterSpacing: "0 ", fontWeight:" 400 "}; function et (e, t, n) {var r = ne.exec (t); retorno r? Math.max (0, r [2] - (n || 0)) + (r [3] || "px"): t} função tt (e, t, n, r, i, o) {var a = "width" === t? 1: 0, s = 0, u = 0; se (n === (r? "borda": "conteúdo")) retornar 0; para (; a <4; a + = 2) "margem "=== n && (u + = E.css (e, n + re [a] ,! 0, i)), r? (" conteúdo "=== n && (u- = E.css (e," preenchimento "+ re [a] ,! 0, i))," margin "! == n && (u- = E.css (e," borda "+ re [a] +" Width ",! 0, i) )) :( u + = E.css (e, "preenchimento" + re [a] ,! 0, i), "preenchimento"! == n? u + = E.css (e, "borda" + re [a ] + "Largura",! 0, i): s + = E.css (e, "borda" + re [a] + "Largura",! 0, i)); return! R && 0 <= o && (u + = Math .max (0, Math.ceil (e ["offset" + t [0] .toUpperCase () + t.slice (1)] - ous-.5)) || 0), u} função nt (e, t, n) {var r = We (e), i = (! b.boxSizingReliable () || n) && "border-box" === E.css (e, "boxSizing",! 1, r) , o = i, a = Fe (e, t, r), s = "deslocamento" + t [0] .toUpperCase () + t.slice (1); if (Me.test (a)) {if ( ! n) retorna a; a = "auto"} retorna (! b.boxSizingReliable () && i || "auto" === a ||!parseFloat (a) && "inline" === E.css (e, "exibição",! 1, r)) && e.getClientRects (). length && (i = "caixa de borda" === E.css (e , "boxSizing",! 1, r), (o = s em e) && (a = e [s])), (a = parseFloat (a) || 0) + tt (e, t, n || (i? "borda": "conteúdo"), o, r, a) + "px"} E.extend ({cssHooks: {opacidade: {get: function (e, t) {if (t) {var n = Fe (e, "opacidade"); return "" === n? "1": n}}}}, cssNumber: {animationIterationCount:! 0, columnCount:! 0, fillOpacity:! 0, flexGrow:! 0 , flexShrink:! 0, fontWeight:! 0, gridArea:! 0, gridColumn:! 0, gridColumnEnd:! 0, gridColumnStart:! 0, gridRow:! 0, gridRowEnd:! 0, gridRowStart:! 0, lineHeight:! 0 , opacidade:! 0, ordem:! 0, órfãos:! 0, viúvas:! 0, zIndex:! 0, zoom:! 0}, cssProps: {}, estilo: função (e, t, n, r) { if (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {var i, o, a, s = X (t), u = Ke.teste (t), l = e.style; se (u || (t = Xe (s)), a = E.cssHooks [t] || E.cssHooks [s], nulo 0 === n) return a && "get" em um && void 0! == (i = a.get (e,! 1, r))? i: l [t]; "string" === (o = tipo de n) && (i = ne .exec (n)) && i [1] && (n = função (e, t, n, r) {var i, o, a = 20, s = r? função () {return r.cur ()}: função () {retornar E.css (e, t, "")}, u = s (), l = n && n [3] || (E.cssNumber [t]? "": "px"), c = e.nodeType && (E.cssNumber [t] || "px"! == l && + u) && ne.exec (E.css (e, t)); if (c && c [3]! == l) {u / = 2, l = l || c [3], c = + u || 1; while (a -) E.style (e, t, c + l), (1-o) * (1- ( o = s () / u || .5)) <= 0 && (a = 0), c / = o; c * = 2, E.style (e, t, c + l), n = n || []} retorna n && (c = + c || + u || 0, i = n [1]? c + (n [1] +1) * n [2]: + n [2], r && (r. unit = l, r.start = c, r.end = i)), i} (e, t, i), o = "número"), nulo! = n && n == n && ("número"!== o || u || (n + = i && i [3] || (E.cssNumber [s]? "": "px")), b.clearCloneStyle || ""! == n || 0! = = t.indexOf ("plano de fundo") || (l [t] = "herdar"), um & "conjunto" em um & & nulo 0 === (n = a.set (e, n, r)) || (u ? l.setProperty (t, n): l [t] = n))}}, css: function (e, t, n, r) {var i, o, a, s = X (t); return Ke .test (t) || (t = Xe (s)), (a = E.cssHooks [t] || E.cssHooks [s]) && "get" em um && (i = a.get (e ,! 0, n)), nulo 0 === i && (i = Fe (e, t, r)), "normal" === i && t em Ze && (i = Ze [t]), "" === n | | n? (o = parseFloat (i) ,! 0 === n || isFinite (o)? o || 0: i): i}}), E.each (["height", "width"] , function (e, u) {E.cssHooks [u] = {get: function (e, t, n) {se (t) retornar! Ge.test (E.css (e, "display")) || e.getClientRects (). length && e.getBoundingClientRect (). width? nt (e, u, n): ue (e, Je, function () {return nt (e, u, n)})},set: function (e, t, n) {var r, i = We (e), o =! b.scrollboxSize () && "absolute" === posição, a = (o || n) && " border-box "=== E.css (e," boxSizing ",! 1, i), s = n? tt (e, u, n, a, i): 0; retorne um && o && (s- = Math. ceil (e ["offset" + u [0] .toUpperCase () + u.slice (1)] - parseFloat (i [u]) - tt (e, u, "border",! 1, i) -. 5)), s && (r = ne.exec (t)) && "px"! == (r [3] || "px") && (e.style [u] = t, t = E.css ( e, u)), et (0, t, s)}}}), E.cssHooks.marginLeft = ze (b.reliableMarginLeft, função (e, t) {if (t) return (parseFloat (Fe (e, "marginLeft")) || e.getBoundingClientRect (). left-ue (e, {marginLeft: 0}, função () {return e.getBoundingClientRect (). left})) + "px"}), E.each ({margin: "", padding: "", border: "Width"}, função (i, o) {E.cssHooks [i + o] = {expand: function (e) {for (var t = 0, n = {}, r = "string "== tipo de e? e.split (" "): [e]; t <4; t ++) n [i + re [t] + o] = r [t] || r [t-2] | | r [0]; return n}}, "margin"! == i && (E.cssHooks [i + o] .set = et)}), E.fn.extend ({css: function (e, t) {return z (esta, função (e, t, n) {var r, i, o = {}, a = 0; if (Array.isArray (t)) {for (r = We (e), i = t.length; a <i; a ++) o [t [a]] = E.css (e, t [a] ,! 1, r); return o} return void 0! == n? E.style ( e, t, n): E.css (e, t)}, e, t, 1 <argumentos.length)}}), E.fn.delay = function (r, e) {return r = E.fx && E .fx.speeds [r] || r, e = e || "fx", this.queue (e, função (e, t) {var n = g.setTimeout (e, r); t.stop = função () {g.clearTimeout (n)}})}, Qe = v.createElement ("entrada"), Ye = v.createElement ("select"). appendChild (v.createElement ("opção")), Qe. tipo = "caixa de seleção", b.checkOn = ""! == Qe.value, b.optSelected = Ye.selected, (Qe = v.createElement ("input")). value = "t",Qe.type = "radio", b.radioValue = "t" === Qe.value; var rt, ele = E.expr.attrHandle; E.fn.extend ({attr: function (e, t) {return z (this, E.attr, e, t, 1 <argumentos.length)}, removeAttr: function (e) {retorna this.each (function () {E.removeAttr (this, e)})}}), E. extender ({attr: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o && 2! == o) retornar "undefined" == typeof e.getAttribute? E.prop (e, t, n) :( 1 === o && E.isXMLDoc (e) || (i = E.attrHooks [t.toLowerCase ()] || (E.expr.match. bool.test (t) rt: void 0)), void 0! == n? null === n? void E.removeAttr (e, t): i && "set" em i && void 0! == (r = i.set (e, n, t))? r: (e.setAttribute (t, n + ""), n): i && "get" em i && null! == (r = i.get (e, t)) ? r: null == (r = E. encontrar.attr (e, t))? void 0: r)}, attrHooks: {tipo: {conjunto: função (e, t) {if (! b.radioValue && " rádio "=== T&& S (e,"input")) {var n = e.value; retorna e.setAttribute ("tipo", t), n && (e.value = n), t}}}}, removeAttr: function (e, t) {var n, r = 0, i = t && t.match (I); if (i && 1 === e.nodeType) while (n = i [r ++]) e.removeAttribute (n)}}), rt = {set: function (e, t, n) {return! 1 === t? E.removeAttr (e, n): e.setAttribute (n, n), n}}, E.each (E.expr.match.bool. source.match (/ \ w + / g), função (e, t) {var a = it [t] || E.find.attr; it [t] = função (e, t, n) {var r, i, o = t.toLowerCase (); return n || (i = it [o], it [o] = r, r = nulo! = a (e, t, n)? o: nulo, it [o ] = i), r}}); var ot = / ^ (?: input | select | textarea | button) $ / i, em = / ^ (?: a | area) $ / i; função st (e) {return (e.match (I) || []). join ("")} função ut (e) {return e.getAttribute && e.getAttribute ("classe") || ""} função lt (e) {return Array.isArray (e)? E: "string" == tipo de e && e.match (I) || []} E.fn.extend ({prop: function (e,t) {return z (this, E.prop, e, t, 1 <argumentos.length)}, removeProp: function (e) {retorna this.each (function () {delete this [E.propFix [e] | | e]})}}), E.extend ({prop: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o && 2! == o) return 1 === o && E.isXMLDoc (e) || (t = E.propFix [t] || t, i = E.propHooks [t]), nulo 0! == n? i && "set" em i && void 0! == (r = i.set (e, n, t))? r: e [t] = n: i && "obtém" em i && null! == (r = i.get (e, t)) ? r: e [t]}, propHooks: {tabIndex: {get: function (e) {var t = E. encontrar.attr (e, "tabindex"); retornar t? parseInt (t, 10): ot. teste (e.nodeName) || at.test (e.nodeName) && e.href? 0: -1}}}, propFix: {"for": "htmlFor", "class": "className"}}), b.optSelected || (E.propHooks.selected = {get: function (e) {var t = e.parentNode; retorne t && t.parentNode && t.parentNode.selectedIndex, null},set: function (e) {var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)}}), E.each (["tabIndex", "readOnly", "maxLength", " cellSpacing "," cellPadding "," rowSpan "," colSpan "," useMap "," frameBorder "," contentEditable "], function () {E.propFix [this.toLowerCase ()] = this}), E.fn .extend ({addClass: function (t) {var e, n, r, i, o, a, s, u = 0; if (x (t)) retorna this.each (function (e) {E (this ) .addClass (t.call (this, e, ut (this)))}); if ((e = lt (t)). length) while (n = this [u ++]) if (i = ut (n ), r = 1 === n.nodeType && "" + st (i) + "") {a = 0; while (o = e [a ++]) r.indexOf ("" + o + "") <0 && ( r + = o + ""); i! == (s = st (r)) && n.setAttribute ("classe", s)} retorna isso}, removeClass: function (t) {var e, n, r, i, o, a, s, u = 0;if (x (t)) retorna this.each (function (e) {E (this) .removeClass (t.call (this, e, ut (this)))}); if (! argument.length) retorna isso .attr ("classe", ""); if ((e = lt (t)). length) while (n = this [u ++]) if (i = ut (n), r = 1 === n. nodeType && "" + st (i) + "") {a = 0; while (o = e [a ++]) while (-1 <r.indexOf ("" + o + "")) r = r.replace (" "+ o +" "," "); i! == (s = st (r)) && n.setAttribute (" classe ", s)} retorne isso}, toggleClass: function (i, t) {var o = typeof i, a = "string" === o || Array.isArray (i); return "boolean" == tipo de && a? t? this.addClass (i): this.removeClass (i): x (i)? this.each (function (e) {E (this) .toggleClass (i.call (this, e, ut (this), t), t), t)}): this.each (function () {var e, t, n, r; se (a) {t = 0, n = E (este), r = lt (i); while (e = r [t ++]) n.hasClass (e)? n.removeClass (e): n.addClass (e)} else void 0! == i &&"booleano"! == o || ((e = ut (this)) && G.set (this, "__ className __", e), this.setAttribute && this.setAttribute ("class", e ||! 1 === i ? ": G.get (this," __ className __ ") ||" "))})}, hasClass: function (e) {var t, n, r = 0; t =" "+ e +" "; while (n = this [r ++]) if (1 === n.nodeType && - 1 <("" + st (ut (n)) + "") .indexOf (t)) return! 0; return! 1}} ); var ct = / \ r / g; E.fn.extend ({val: function (n) {var r, e, i, t = this [0]; return argumentos.length? (i = x (n ), this.each (function (e) {var t; 1 === this.nodeType && (null == (t = i? n.call (this, e, E (this) .val ()): n) ? t = "": "number" == typeof t? t + = "": Array.isArray (t) && (t = E.map (t, função (e) {return null == e? "": e + ""})), (r = E.valHooks [this.type] || E.valHooks [this.nodeName.toLowerCase ()]) && "set"em r && void 0! == r.set (this, t, "value") || (this.value = t))})): t? (r = E.valHooks [t.type] || E.valHooks [t.nodeName.toLowerCase ()]) && "get" em r && void 0! == (e = r.get (t, "valor"))? e: "string" == typeof (e = t.value) ? e.replace (ct, ""): null == e? "": e: void 0}}), E. extender ({valHooks: {option: {get: function (e) {var t = E. find.attr (e, "valor"); return null! = t? t: st (E.text (e))}}, selecione: {get: function (e) {var t, n, r, i = e.options, o = e.selectedIndex, a = "select one" === e.type, s = a? null: [], u = a? o + 1: i.length; for (r = o <0? U: a? O: 0; r <u; r ++) if (((n = i [r]). Selected || r === o) &&! N.disabled && (! N.parentNode.disabled S (n.parentNode, "optgroup"))) {if (t = E (n) .val (), a) return t; s.push (t)} return s}, defina: function (e , t) {var n, r, i = e.opções, o = E.makeArray (t), a = i.length; while (a -) ((r = i [a]).selecionado = -1 <E.inArray (E.valHooks.option.get (r), o)) && (n =! 0); return n || (e.selectedIndex = -1), o}}}}) , E.each (["radio", "checkbox"], function () {E.valHooks [this] = {set: function (e, t) {if (Array.isArray (t)) retorna e.checked = -1 <E.inArray (E (e) .val (), t)}}, b.checkOn || (E.valHooks [isto] .get = function (e) {return null === e.getAttribute ( "valor")? "on": e.value})}), b.focusin = "onfocusin" em g; var ft = / ^ (?: focusinfocus | focusoutblur) $ /, dt = function (e) {e .stopPropagation ()}; E.extend (E.event, {trigger: function (e, t, n, r) {var i, o, a, s, u, l, c, f, d = [n | | v], p = m.call (e, "tipo")? e.type: e, h = m.call (e, "namespace")? e.namespace.split ("."): []; if (o = f = a = n = n || v, 3! == n.nodeType && 8! == n.nodeType &&! ft.test (p + E.event.triggered) && (- 1 <p.indexOf ( ".") && (p = (h = p. divisão ("."))).shift (), h.sort ()), u = p.indexOf (":") <0 && "on" + p, (e = e [E.expando]? e: novo objeto E.Event (p, " "== tipo de e && e)). isTrigger = r? 2: 3, e.namespace = h.join (". "), e.rnamespace = e.namespace? new RegExp (" (^ | \\.) " h.join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, e.result = void 0, e.target || (e.target = n), t = nulo == t? [e]: E.makeArray (t, [e]), c = E.event.special [p] || {}, r ||! c.trigger || ! 1! == c.trigger.apply (n, t))) {if (! R &&! C.noBubble &&! W (n)) {for (s = c.delegateType || p, ft.test (s + p) || (o = o.parentNode); o; o = o.parentNode) d.push (o), a = o; a === (n.ownerDocument || v) && d.push (a.defaultView || a.parentWindow || g)} i = 0; while ((o = d [i ++]) &&! e.isPropagationStopped ()) f = o, e.type = 1 <i? s: c.bindType | | p, (l = (G.get (o, "eventos") || {}) [e.type] && G.get (o, "manipulador")) && l.apply (o, t),(l = u && o [u]) && l.apply && Q (o) && (e.result = l.apply (o, t) ,! 1 === resultado e. && e.preventDefault ()); return e.type = p, r || e.isDefaultPrevented () || c._default &&! 1! == c._default.apply (d.pop (), t) ||! Q (n) || u && x (n [p]) &&! w (n) && ((a = n [u]) && (n [u] = nulo), E.event.triggered = p, e.isPropagationStopped () && f.addEventListener (p, dt), n [p] (), e.isPropagationStopped () && f.removeEventListener (p, dt), E.event.triggered = void 0, a && (n [u] = a)), e.result}}, simule: function (e, t , n) {var r = E. extender (novo E.Event, n, {tipo: e, isSimulated:! 0}); E.event.trigger (r, null, t)}}), E.fn. estender ({trigger: function (e, t) {retornar this.each (function () {E.event.trigger (e, t, this)})}, triggerHandler: function (e, t) {var n = this [0]; se (n) retornar E.event.trigger (e, t, n,! 0)}}), b.focusin || E.each ({focus: "focusin", blur: "focusout "}, função (n, r) {vari = função (e) {E.event.simulate (r, e.target, E.event.fix (e))}; E.event.special [r] = {setup: function () {var e = this.ownerDocument || this, t = G.access (e, r); t || e.addEventListener (n, i,! 0), G.access (e, r, (t || 0) +1)}, desmontagem: function () {var e = this.ownerDocument || this, t = G.access (e, r) -1; t? G.access (e, r, t) :( e.removeEventListener (n, i,! 0), G.remove (e, r))}}}); var pt, ht = / \ [\] $ /, gt = / \ r ? \ n / g, vt = / ^ (?: enviar | botão | imagem | redefinir | arquivo) $ / i, yt = / ^ (?: entrada | selecionar | textarea | keygen) / i; função mt (n, e, r, i) {var t; if (Array.isArray (e)) E.each (e, função (e, t) {r || ht.test (n)? i (n, t): mt (n + "[" + ("objeto" == tipo de t && null! = t? e: "") + "]", t, r, i)}); caso contrário, se (r || "objeto"! == T (e)) i (n, e); mais para (t em e) mt (n + "[" + t + "]", e [t], r, i)} E.param = function (e, t) {var n, r = [], i = função (e, t) {var n = x (t)? t (): t; r [r.length] = encodeURIComponent (e) + "=" + encodeURIComponent (null == n? "": n)}; if (null == e) return ""; if (Array.isArray (e) || e.jquery && ! E.isPlainObject (e)) E.each (e, function () {i (this.name, this.value)}); mais para (n em e) mt (n, e [n], t, i ); return r.join ("&")}, E.fn.extend ({serialize: function () {return E.param (this.serializeArray ())}, serializeArray: function () {return this.map ( function () {var e = E.prop (this, "elements"); return e? E.makeArray (e): this}). filter (function () {var e = this.type; return this.name &&! E (this) .is (": disabled") && yt.test (this.nodeName) &&! Vt.test (e) && (this.checked ||! Fe.test (e))}). Map (function ( e, t) {var n = E (this) .val (); return null == n? null: Array.isArray (n)? E.map (n, function (e) {return {name: t.name , valor: e.replace (gt, "\ r \ n")}}): {nome: t.name, valor: n.replace (gt,"\ r \ n")}}). get ()}}), E.fn.extend ({wrapAll: function (e) {var t; retorna isso [0] && (x (e) && (e = e.call (this [0])), t = E (e, this [0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && t.insertBefore (this [0]) , t.map (function () {var e = this; while (e.firstElementChild) e = e.firstElementChild; return e}). append (this)), this}, wrapInner: function (n) {return x ( n)? this.each (function (e) {E (this) .wrapInner (n.call (this, e))}): this.each (function () {var e = E (this), t = e .contents (); t.length? t.wrapAll (n): e.append (n)})}, wrap: function (t) {var n = x (t); retorna this.each (function (e) {E (this) .wrapAll (n? T.call (this, e): t)})}, desembrulhar: function (e) {retornar this.parent (e) .not ("body"). Each (function () {E (this) .replaceWith (this.childNodes)}), this}}), E.expr.pseudos.hidden = function (e) {return! E.expr.pseudos.visible (e)}, E .expr.pseudos.visible = função (e) {retornar !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). length)}, b.createHTMLDocument = ((pt = v.implementação.createHTMLDocument ("")) body) .innerHTML = "<form> </form> < form> </form> ", 2 === pt.childNodes.length), E.parseHTML = function (e, t, n) {return" string "! = typeof e? [] :(" boolean "== tipo de t && (n = t, t =! 1), t || (b.criarHTMLDocument? ((r = (t = v.implementation.createHTMLDocument ("")). createElement ("base")). href = v .location.href, t.head.appendChild (r)): t = v), o =! n && [], (i = D.exec (e))? [t.createElement (i [1])]: (i = xe ([e], t, o), o && o.length && E (o) .remove (), E.merge ([], i.childNodes))); var r, i, o}, E.offset = {setOffset: function (e, t, n) {var r, i, o, a, s, u, l = E.css (e, "posição"), c = E (e), f = {} ; "estático" === l && (e.style.posição = "relativa"), s = c.offset (), o = E.css (e, "superior"), u = E.css (e, "esquerda"), ("absoluto" === l || "fixo" === l) && - 1 <(o + u). indexOf ("auto")? (a = (r = c.position ()). top, i = r.left) :( a = parseFloat (o) || 0, i = parseFloat (u) || 0) , x (t) && (t = t.call (e, n, E. extender ({}, s))), nulo! = t.top && (f.top = t.top-s.top + a) , null! = t.left && (f.left = t.left-s.left + i), "using" em t? t.using.call (e, f): c.css (f)}}, E .fn.extend ({offset: function (t) {if (argument.length) retorna nulo 0 === t? this: this.each (function (e) {E.offset.setOffset (this, t, e) }); var e, n, r = este [0]; retornar r? r.getClientRects (). length? (e = r.getBoundingClientRect (), n = r.ownerDocument.defaultView, {top: e.top + n.pageYOffset, esquerda: e.left + n.pageXOffset}): {top: 0, esquerda: 0}: void 0}, position: function () {if (this [0]) {var e, t, n , r = this [0], i = {top: 0, left: 0}; if ("fixo" === E.css (r, "posição")) t = r.getBoundingClientRect (); else {t = this.offset (), n = r.ownerDocument, e = r.offsetParent || n.documentElement; while (e && (e === n.body || e === n. documentElement) && "static" === E.css (e, "position")) e = e.parentNode; e && e! == r && 1 === e.nodeType && ((i = E (e) .offset ()) .top + = E.css (e, "borderTopWidth",! 0), i.left + = E.css (e, "borderLeftWidth",! 0))} return {top: t.top-i.top-E. css (r, "marginTop",! 0), à esquerda: t.left-i.left-E.css (r, "marginLeft",! 0)}}}, offsetParent: function () {retorna this.map ( function () {var e = this.offsetParent; while (e && "static" === E.css (e, "position")) e = e.offsetParent; return e || ie})}}), E. cada ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, função (t, i) {var o = "pageYOffset" === i; E.fn [t] = function (e) {return z (this , função (e, t,n) {var r; se (w (e)? r = e: 9 === tipo e.node && (r = e.defaultView), nulo 0 === n) retornar r? r [i]: e [t ]; r? r.scrollTo (o? r.pageXOffset: n, o? n: r.pageYOffset): e [t] = n}, t, e, argumentos. comprimento)}}), E.each ([ "top", "left"], função (e, n) {E.cssHooks [n] = ze (b.pixelPosition, função (e, t) {se (t) retornar t = Fe (e, n), Me.test (t)? E (e) .position () [n] + "px": t})}), E.each ({Altura: "altura", Largura: "largura"}, função (a , s) {E.each ({padding: "inner" + a, content: s, "": "outer" + a}, função (r, o) {E.fn [o] = função (e, t ) {var n = argument.length && (r || "booleano"! = tipo de e), i = r || (! 0 === e ||! 0 === t? "margin": "border") ; return z (esta função (e, t, n) {var r; return w (e)? 0 === o.indexOf ("externo")? e ["interno" + a]: e.document. documentElement ["cliente" + a]: 9 === e.nodeType? (r = e.documentElement,Math.max (e.body ["scroll" + a], r ["scroll" + a], e.body ["offset" + a], r ["offset" + a], r ["client" + a])): void 0 === n E.css (e, t, i): E.style (e, t, n, i)}, s, n? e: void 0, n)}} )}), E.each ("desfoque foco foco em foco redimensionar rolagem clique em dblclick mouse com mouse desativado mousemove mouseover mouseout mouseenter mouseleave alterar selecionar enviar tecla pressionada tecla pressionada tecla contextmenu" .split (""), função (e, n) n] = função (e, t) {retornar 0 <argumentos.length? this.on (n, nulo, e, t): this.trigger (n)}}), E.fn.extend ({hover: function (e, t) {retorna this.mouseenter (e) .mouseleave (t || e)}}), E.fn.extend ({bind: function (e, t, n) {retorna this.on (e, null, t, n)}, unbind: function (e, t) {retorna this.off (e, null, t)}, delega: function (e, t, n, r) {retorna this.on (t, e, n, r)}, undelegate: function (e, t, n) {return 1 === argumentos.length? this.off (e, "**"): isto.off (t, e || "**", n)}}), E.proxy = function (e, t) {var n, r, i; if ("string" == tipo de t && (n = e [ t], t = e, e = n), x (e)) retorna r = s.call (argumentos, 2), (i = função () {retorna e.apply (t || isto, r.concat ( s.call (argumentos)))}). guid = e.guid = e.guid || E.guid ++, i}, E.holdReady = função (e) {e? E.readyWait ++: E.ready (! 0 )}, E.isArray = Array.isArray, E.parseJSON = JSON.parse, E.nodeName = S, E.isFunction = x, E.isWindow = w, E.camelCase = X, E.type = T, E .now = Date.now, E.isNumeric = function (e) {var t = E.type (e); return ("number" === t || "string" === t) &&! isNaN (e -parseFloat (e))}, "function" = tipo de definir && define.amd && define ("jquery", [], function () {return E}); var bt = g.jQuery, xt = g. $; return E. noConflict = function (e) {return g. $ === E && (g. $ = xt), e && g.jQuery === E && (g.jQuery = bt), E}, e || (g.jQuery = g . $ = E), E});** ", n)}}), E.proxy = function (e, t) {var n, r, i; if (" string "== tipo de t && (n = e [t], t = e, e = n), x (e)) retorna r = s.call (argumentos, 2), (i = function () {retorna e.apply (t || isso, r.concat (s.call (argumentos))) }). guid = e.guid = e.guid || E.guid ++, i}, E.holdReady = função (e) {e? E.readyWait ++: E.ready (! 0)}, E.isArray = matriz .isArray, E.parseJSON = JSON.parse, E.nodeName = S, E.isFunction = x, E.isWindow = w, E.camelCase = X, E.type = T, E.now = Date.now, E .isNumeric = função (e) {var t = E.tipo (e); return ("number" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, "function" == tipo de definir && define.amd && define ("jquery", [], função () {retornar E}); var bt = g.jQuery, xt = g. $; return E.noConflict = function (e) {return g. $ === E && (g. $ = xt), e && g.jQuery === E && (g.jQuery = bt), E}, e || (g.jQuery = g. $ = E), E} );** ", n)}}), E.proxy = function (e, t) {var n, r, i; if (" string "== tipo de t && (n = e [t], t = e, e = n), x (e)) retorna r = s.call (argumentos, 2), (i = function () {retorna e.apply (t || isso, r.concat (s.call (argumentos))) }). guid = e.guid = e.guid || E.guid ++, i}, E.holdReady = função (e) {e? E.readyWait ++: E.ready (! 0)}, E.isArray = matriz .isArray, E.parseJSON = JSON.parse, E.nodeName = S, E.isFunction = x, E.isWindow = w, E.camelCase = X, E.type = T, E.now = Date.now, E .isNumeric = função (e) {var t = E.tipo (e); return ("number" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, "function" == tipo de definir && define.amd && define ("jquery", [], função () {retornar E}); var bt = g.jQuery, xt = g. $; return E.noConflict = function (e) {return g. $ === E && (g. $ = xt), e && g.jQuery === E && (g.jQuery = bt), E}, e || (g.jQuery = g. $ = E), E} );t) {var n, r, i; if ("string" == tipo de t && (n = e [t], t = e, e = n), x (e)) retorna r = s.call (argumentos, 2), (i = function () {retorna e.apply (t || isto, r.concat (s.call (argumentos)))}). Guid = e.guid = e.guid || E.guid ++, i}, E.holdReady = função (e) {e? E.readyWait ++: E.ready (! 0)}, E.isArray = Array.isArray, E.parseJSON = JSON.parse, E.nodeName = S, E .isFunction = x, E.isWindow = w, E.camelCase = X, E.type = T, E.now = Date.now, E.isNumeric = função (e) {var t = E.tipo (e); return ("number" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, "function" == tipo de definição && define.amd && define ("jquery", [], function () {return E}); var bt = g.jQuery, xt = g. $; return E.noConflict = function (e) {return g. $ === E && (g. $ = xt), e && g.jQuery === E && (g.jQuery = bt), E}, e || (g.jQuery = g. $ = E), E});t) {var n, r, i; if ("string" == tipo de t && (n = e [t], t = e, e = n), x (e)) retorna r = s.call (argumentos, 2), (i = function () {retorna e.apply (t || isto, r.concat (s.call (argumentos)))}). Guid = e.guid = e.guid || E.guid ++, i}, E.holdReady = função (e) {e? E.readyWait ++: E.ready (! 0)}, E.isArray = Array.isArray, E.parseJSON = JSON.parse, E.nodeName = S, E .isFunction = x, E.isWindow = w, E.camelCase = X, E.type = T, E.now = Date.now, E.isNumeric = função (e) {var t = E.tipo (e); return ("number" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, "function" == tipo de definição && define.amd && define ("jquery", [], function () {return E}); var bt = g.jQuery, xt = g. $; return E.noConflict = function (e) {return g. $ === E && (g. $ = xt), e && g.jQuery === E && (g.jQuery = bt), E}, e || (g.jQuery = g. $ = E), E});x (e)) retorna r = s.call (argumentos, 2), (i = function () {retorna e.apply (t || isto, r.concat (s.call (argumentos)))}). guid = e.guid = e.guid || E.guid ++, i}, E.holdReady = função (e) {e? E.readyWait ++: E.ready (! 0)}, E.isArray = Array.isArray, E .parseJSON = JSON.parse, E.nodeName = S, E.isFunction = x, E.isWindow = w, E.camelCase = X, E.type = T, E.now = Date.now, E.isNumeric = function (e) {var t = E.tipo (e); return ("number" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, "function" = = typeof define && define.amd && define ("jquery", [], função () {retornar E}); var bt = g.jQuery, xt = g. $; return E.noConflict = function (e) {return g. $ = == E && (g. $ = Xt), e && g.jQuery === E && (g.jQuery = bt), E}, e || (g.jQuery = g. $ = E), E});x (e)) retorna r = s.call (argumentos, 2), (i = function () {retorna e.apply (t || isto, r.concat (s.call (argumentos)))}). guid = e.guid = e.guid || E.guid ++, i}, E.holdReady = função (e) {e? E.readyWait ++: E.ready (! 0)}, E.isArray = Array.isArray, E .parseJSON = JSON.parse, E.nodeName = S, E.isFunction = x, E.isWindow = w, E.camelCase = X, E.type = T, E.now = Date.now, E.isNumeric = function (e) {var t = E.tipo (e); return ("number" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, "function" = = typeof define && define.amd && define ("jquery", [], função () {retornar E}); var bt = g.jQuery, xt = g. $; return E.noConflict = function (e) {return g. $ = == E && (g. $ = Xt), e && g.jQuery === E && (g.jQuery = bt), E}, e || (g.jQuery = g. $ = E), E});holdReady = função (e) {e? E.readyWait ++: E.ready (! 0)}, E.isArray = Array.isArray, E.parseJSON = JSON.parse, E.nodeName = S, E.isFunction = x, E.isWindow = w, E.camelCase = X, E.type = T, E.now = Date.now, E.isNumeric = função (e) {var t = E.tipo (e); return ("number" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, "function" == tipo de definição && define.amd && define ("jquery", [], function () {return E }); var bt = g.jQuery, xt = g. $; return E.noConflict = function (e) {return g. $ === E && (g. $ = xt), e && g.jQuery === E && ( g.jQuery = bt), E}, e || (g.jQuery = g. $ = E), E});holdReady = função (e) {e? E.readyWait ++: E.ready (! 0)}, E.isArray = Array.isArray, E.parseJSON = JSON.parse, E.nodeName = S, E.isFunction = x, E.isWindow = w, E.camelCase = X, E.type = T, E.now = Date.now, E.isNumeric = função (e) {var t = E.tipo (e); return ("number" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, "function" == tipo de definição && define.amd && define ("jquery", [], function () {return E }); var bt = g.jQuery, xt = g. $; return E.noConflict = function (e) {return g. $ === E && (g. $ = xt), e && g.jQuery === E && ( g.jQuery = bt), E}, e || (g.jQuery = g. $ = E), E});! isNaN (e-parseFloat (e))}, "function" == tipo de definição && define.amd && define ("jquery", [], function () {return E}); var bt = g.jQuery, xt = g. $ ; return E.noConflict = function (e) {return g. $ === E && (g. $ = xt), e && g.jQuery === E && (g.jQuery = bt), E}, e || (g .jQuery = g. $ = E), E});! isNaN (e-parseFloat (e))}, "function" == tipo de definição && define.amd && define ("jquery", [], function () {return E}); var bt = g.jQuery, xt = g. $ ; return E.noConflict = function (e) {return g. $ === E && (g. $ = xt), e && g.jQuery === E && (g.jQuery = bt), E}, e || (g .jQuery = g. $ = E), E});